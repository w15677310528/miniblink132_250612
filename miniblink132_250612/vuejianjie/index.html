<!DOCTYPE html>

<html style="font-size: 100px">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>è‹±é›„ç”»å»Š - è‡ªå®šä¹‰å¸ƒå±€</title>

  <script>
    //remå±å¹•é€‚åº”, å®½åº¦å¤§äº2560æ—¶ï¼Œå­—ä½“å¤§å°ä¸º100pxï¼Œå®½åº¦å°äº50pxæ—¶ï¼Œå­—ä½“å¤§å°ä¸º50px 
    (function (win, doc) {
      if (!win.addEventListener) return;
      function setFont() {
        var html = document.documentElement;
        var k = 2560;
        if ((html.clientWidth / k) * 100 >= 150)
          html.style.fontSize = "150px";
        else if ((html.clientWidth / k) * 100 <= 50)
          html.style.fontSize = "50px";
        else html.style.fontSize = (html.clientWidth / k) * 100 + "px";
      }
      setFont();
      setTimeout(function () {
        setFont();
      }, 300);
      doc.addEventListener("DOMContentLoaded", setFont, false);
      win.addEventListener("resize", setFont, false);
      win.addEventListener("load", setFont, false);
    })(window, document);
  </script>
  <!-- æ·»åŠ CSPç­–ç•¥ è¿™ä¸ªå¼ºè¡Œhttps -->
  <!-- <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests" />-->
  <!-- å…¶ä»–å†…å®¹ä¸å˜ -->

  <script src="./js/v3.2.8/vue.global.prod.js" type="text/javascript" charset="utf-8"></script>
  <script src="http://localhost:8899/cdp.js" crossorigin="anonymous"></script>
  <!-- å¼•å…¥CSSæ–‡ä»¶ -->
  <link rel="stylesheet" href="./css/style.css" type="text/css" />
</head>

<body>
  <div id="app">
    <!-- æ–°ç‰ˆé¡¶éƒ¨èœå•æ æ•´ä½“åŒ…è£¹ -->
    <div v-if="!loading" class="top-menu-bar">
      <div class="top-menu-btn-row">
        <button :class="['top-menu-btn', {active: topMenu==='lineup'}]" @click="toggleTopMenu('lineup')">é˜µå®¹</button>
        <button :class="['top-menu-btn', {active: topMenu==='feature'}]" @click="toggleTopMenu('feature')">åŠŸèƒ½</button>
      </div>

    </div>
    <!-- ç«™ä½å›¾çª—å£ -->
    <div v-if="showPositionPanel" class="position-panel">
      <!-- é˜¶æ®µåˆ‡æ¢æŒ‰é’® -->
      <!-- ç«™ä½æŠ€å·§ -->
      <div v-if="selectedLineup && getPositionInfo()" class="hex-strategy-section">
        <div class="hex-strategy-hover">
          <div class="hex-strategy-trigger" @mouseenter="showPositionStrategyTooltip($event)"
            @mouseleave="hidePositionStrategyTooltip">
            <span class="position-strategy-text">ğŸ’¡ ç«™ä½æŠ€å·§</span>
          </div>
          <div class="position-strategy-tooltip" v-show="positionStrategyTooltipVisible">
            {{ getPositionInfo() }}
          </div>
        </div>
      </div>
      <div class="position-stage-btns">

        <button :class="['position-stage-btn', {active: currentBoardLevel === 'l6', disabled: !hasStageData('l6')}]"
          @click="switchPositionStage('l6')" :disabled="!hasStageData('l6')">æ—©æœŸ</button>
        <button :class="['position-stage-btn', {active: currentBoardLevel === 'l8', disabled: !hasStageData('l8')}]"
          @click="switchPositionStage('l8')" :disabled="!hasStageData('l8')">ä¸­æœŸ</button>
        <button :class="['position-stage-btn', {active: currentBoardLevel === 'l9'}]"
          @click="switchPositionStage('l9')">æœ€ç»ˆ</button>

        <!-- L9é˜¶æ®µåæ ‡åˆ‡æ¢æŒ‰é’® -->
        <template v-if="currentBoardLevel === 'l9' && hasL9SecondaryCoordinates">
          <button :class="['position-coordinate-btn', {active: l9CoordinateMode === 'primary'}]"
            @click="switchL9CoordinateMode('primary')" title="æ˜¾ç¤ºä¸»è¦åæ ‡(x,y)">ç«™ä½1</button>
          <button :class="['position-coordinate-btn', {active: l9CoordinateMode === 'secondary'}]"
            @click="switchL9CoordinateMode('secondary')" title="æ˜¾ç¤ºå¤‡ç”¨åæ ‡(x2,y2)">ç«™ä½2</button>
        </template>
      </div>

      <!-- ç«™ä½å›¾åº•å›¾ -->
      <div class="lineup-location">

        
        <!-- è‹±é›„åæ ‡ç‚¹ -->
        <div v-for="hero in getCurrentBoardHeroList()" :key="'pos-' + hero.x + '-' + hero.y" class="location-champion"
          :class="'position' + hero.x + '-' + hero.y"
          @mouseenter="hero.chessData && showHeroTooltip(hero.chessData, $event)" @mouseleave="hideHeroTooltip">
          <!-- è‹±é›„å¤´åƒå›¾ç‰‡ -->
          <i v-if="hero.chessData" class="hero-avatar-icon"
            :style="{backgroundImage: 'url(' + hero.chessData.name + ')'}"></i>
        </div>

        <!-- ç¼ºå¤±å‰ä¸­æœŸé˜µå®¹æç¤ºé®ç½© -->
        <div
          v-if="!hasStageData('l6') && !hasStageData('l8') && (currentBoardLevel === 'l6' || currentBoardLevel === 'l8')"
          class="position-missing-notice">
          <div class="missing-notice-content">
            <i class="missing-notice-icon">âš ï¸</i>
            <div class="missing-notice-text">
              <div class="missing-notice-title">æ²¡æœ‰å‰ä¸­æœŸé˜µå®¹</div>
              <div class="missing-notice-desc">è¯¥é˜µå®¹æš‚æ— å‰æœŸå’Œä¸­æœŸé˜¶æ®µçš„è‹±é›„é…ç½®æ•°æ®</div>
            </div>
          </div>
        </div>

        <!-- ç¼ºå¤±å•ä¸ªé˜¶æ®µæ•°æ®æç¤ºé®ç½© -->
        <div v-else-if="!hasStageData(currentBoardLevel)" class="position-missing-notice">
          <div class="missing-notice-content">
            <i class="missing-notice-icon">âš ï¸</i>
            <div class="missing-notice-text">
              <div class="missing-notice-title">{{ getStageName(currentBoardLevel) }}é˜¶æ®µæ•°æ®ç¼ºå¤±</div>
              <div class="missing-notice-desc">è¯¥é˜µå®¹æš‚æ— {{ getStageName(currentBoardLevel) }}é˜¶æ®µçš„è‹±é›„é…ç½®æ•°æ®</div>
            </div>
          </div>
        </div>

        <!-- æ— ç«™ä½åæ ‡æç¤ºé®ç½© -->
        <div v-else-if="!hasValidPositions()" class="position-missing-notice">
          <div class="missing-notice-content">
            <i class="missing-notice-icon">ğŸ“</i>
            <div class="missing-notice-text">
              <div class="missing-notice-title">ç«™ä½å›¾æš‚ä¸å¯ç”¨</div>
              <div class="missing-notice-desc">è¯¥é˜µå®¹çš„{{ getStageName(currentBoardLevel) }}é˜¶æ®µæš‚æ— ç«™ä½åæ ‡æ•°æ®</div>
            </div>
          </div>
        </div>
      </div>


    </div>

    <div v-if="showLineupDetail" class="lineup-detail-panel">

      <div v-if="selectedLineup" class="lineup-detail-content">
        <!-- å…³é—­æŒ‰é’® -->
        <button class="lineup-detail-close-btn" @click="closeLineupDetail" title="å…³é—­é˜µå®¹è¯¦æƒ…">Ã—</button>

        <!-- é˜µå®¹æ ‡é¢˜åŒº -->
        <div class="lineup-title-row">




          <div class="selectedLineup-quality" :class="'quality-' + selectedLineup.quality.toLowerCase()">
            <img :src="'./img/icon-tier-' + selectedLineup.quality + '.webp'" :alt="selectedLineup.quality"
              class="quality-icon" />
          </div>



          <span class="lineup-title">{{ selectedLineup.name }}</span>
        </div>
        <!-- é˜¶æ®µåˆ‡æ¢æŒ‰é’®å’Œç«™ä½å›¾æŒ‰é’® -->
        <div class="stage-toggle-btns">
          <div :class="['stage-toggle-btn', {active: showEarlyMid}]" @click="showEarlyMid = !showEarlyMid">
            <span class="filter-checkbox">
              <span v-if="showEarlyMid" class="checkbox-inner"></span>
            </span>
            <span class="filter-label">{{ showEarlyMid ? 'éšè—å‰ä¸­æœŸé˜µå®¹' : 'æ˜¾ç¤ºå‰ä¸­æœŸé˜µå®¹' }}</span>
          </div>


        </div>
        <!-- é˜¶æ®µè‹±é›„å¤´åƒåŒº -->
        <div class="lineup-stage-row">
          <template v-if="showEarlyMid">
            <!-- L6å‰æ’é˜µå®¹ - åªæœ‰å½“æœ‰æœ‰æ•ˆè‹±é›„æ•°æ®æ—¶æ‰æ˜¾ç¤º -->
            <div
              v-if="selectedLineup.hero_location_l6 && selectedLineup.hero_location_l6.length > 0 && selectedLineup.hero_location_l6.some(hero => hero.chessData && hero.chessData.price !== '0')"
              class="stage-heroes">
              <!-- å‰æ’ä½ç½®æ ‡è¯† -->
              <div class="position-indicator front-row">å‰</div>
              <div v-for="hero in selectedLineup.hero_location_l6 || []"
                :key="'l6-' + (hero.chessData ? hero.chessData.chessId : 'missing-' + Math.random())" class="stage-hero"
                style="position:relative;pointer-events:auto;" v-show="!hero.chessData || hero.chessData.price !== '0'">
                <div class="stage-hero-cell"
                  :class="{ 'selected': hero.chessData && isHeroSelected(hero.chessData.chessId) }"
                  @click="hero.chessData && selectHero(hero.chessData)">
                  <img v-if="hero.chessData" class="stage-hero-avatar"
                    :src="hero.chessData.name"
                    :alt="hero.chessData.displayName" @mouseenter="showHeroTooltip(hero.chessData, $event)"
                    @mouseleave="hideHeroTooltip" />
                  <div v-else class="stage-hero-missing">å·²åˆ é™¤</div>

                </div>
                <img v-if="hero.isCore" class="icon-carry-center" src="img/icon-carry-hero.png" alt="Cä½"
                  @mouseenter="showTooltipText('æ ¸å¿ƒCä½è‹±é›„', $event)" @mouseleave="hideTooltipText" />
                <div class="star-row" v-if="hero.isThreeStar" @mouseenter="showTooltipText('ä¸‰æ˜Ÿè‹±é›„', $event)"
                  @mouseleave="hideTooltipText">
                  <span class="icon-star" v-for="star in 3" :key="star">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="15" fill="none" viewBox="0 0 16 15">
                      <path fill="#ffd900" fill-rule="evenodd"
                        d="m8 11.75-4.408 2.318.842-4.91L.867 5.683l4.929-.716L8 .5l2.204 4.466 4.929.716-3.566 3.477.841 4.909z"
                        clip-rule="evenodd"></path>
                    </svg>
                  </span>
                </div>
                <div class="equipment-list">
                  <div class="component-equipment" v-for="(equip, idx) in hero.equipData" :key="idx"
                    @mouseenter="showEquipTooltip(equip, $event)" @mouseleave="hideEquipTooltip">
                    <div class="equip-pic">
                      <img :src="equip.imagePath" :alt="equip.name" />
                    </div>
                  </div>

                </div>
              </div>
              <div v-if="selectedLineup.early_info" class="hex-strategy-section">
                <div class="hex-strategy-hover">
                  <div class="hex-strategy-trigger" @mouseenter="showEarlyStrategyTooltip($event)"
                    @mouseleave="hideEarlyStrategyTooltip">
                    <span class="early-strategy-text">ğŸ’¡ å‰æœŸè¿‡åº¦</span>
                  </div>
                  <div class="early-strategy-tooltip" v-show="earlyStrategyTooltipVisible">
                    {{ selectedLineup.early_info }}
                  </div>
                </div>
              </div>
            </div>

            <!-- L6å‰æ’ç©ºæç¤º -->
            <div
              v-else-if="!selectedLineup.hero_location_l6 || selectedLineup.hero_location_l6.length === 0 || !selectedLineup.hero_location_l6.some(hero => hero.chessData && hero.chessData.price !== '0')"
              class="stage-empty-hint">
              <span class="empty-hint-text">ğŸ“ å‰æœŸé˜µå®¹ï¼šæ— ç‰¹å®šè‹±é›„æ¨èï¼Œçµæ´»è¿‡æ¸¡</span>
            </div>

            <!-- L8ä¸­æ’é˜µå®¹ - åªæœ‰å½“æœ‰æœ‰æ•ˆè‹±é›„æ•°æ®æ—¶æ‰æ˜¾ç¤º -->
            <div
              v-if="selectedLineup.hero_location_l8 && selectedLineup.hero_location_l8.length > 0 && selectedLineup.hero_location_l8.some(hero => hero.chessData && hero.chessData.price !== '0')"
              class="stage-heroes">
              <!-- ä¸­æ’ä½ç½®æ ‡è¯† -->
              <div class="position-indicator mid-row">ä¸­</div>
              <div v-for="hero in selectedLineup.hero_location_l8 || []"
                :key="'l8-' + (hero.chessData ? hero.chessData.chessId : 'missing-' + Math.random())" class="stage-hero"
                style="position:relative;pointer-events:auto;" v-show="!hero.chessData || hero.chessData.price !== '0'">
                <div class="stage-hero-cell"
                  :class="{ 'selected': hero.chessData && isHeroSelected(hero.chessData.chessId) }"
                  @click="hero.chessData && selectHero(hero.chessData)">
                  <img v-if="hero.chessData" class="stage-hero-avatar"
                    :src="hero.chessData.name"
                    :alt="hero.chessData.displayName" @mouseenter="showHeroTooltip(hero.chessData, $event)"
                    @mouseleave="hideHeroTooltip" />
                  <div v-else class="stage-hero-missing">å·²åˆ é™¤</div>

                </div>
                <img v-if="hero.isCore" class="icon-carry-center" src="img/icon-carry-hero.png" alt="Cä½"
                  @mouseenter="showTooltipText('æ ¸å¿ƒCä½è‹±é›„', $event)" @mouseleave="hideTooltipText" />
                <div class="star-row" v-if="hero.isThreeStar" @mouseenter="showTooltipText('ä¸‰æ˜Ÿè‹±é›„', $event)"
                  @mouseleave="hideTooltipText">
                  <span class="icon-star" v-for="star in 3" :key="star">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="15" fill="none" viewBox="0 0 16 15">
                      <path fill="#ffd900" fill-rule="evenodd"
                        d="m8 11.75-4.408 2.318.842-4.91L.867 5.683l4.929-.716L8 .5l2.204 4.466 4.929.716-3.566 3.477.841 4.909z"
                        clip-rule="evenodd"></path>
                    </svg>
                  </span>
                </div>
                <div class="equipment-list">
                  <div class="component-equipment" v-for="(equip, idx) in hero.equipData" :key="idx"
                    @mouseenter="showEquipTooltip(equip, $event)" @mouseleave="hideEquipTooltip">
                    <div class="equip-pic">
                      <img :src="equip.imagePath" :alt="equip.name" />
                    </div>
                  </div>

                </div>
              </div>
            </div>

            <!-- L8ä¸­æ’ç©ºæç¤º -->
            <div
              v-else-if="!selectedLineup.hero_location_l8 || selectedLineup.hero_location_l8.length === 0 || !selectedLineup.hero_location_l8.some(hero => hero.chessData && hero.chessData.price !== '0')"
              class="stage-empty-hint">
              <span class="empty-hint-text">ğŸ“ ä¸­æœŸé˜µå®¹ï¼šæ— ç‰¹å®šè‹±é›„æ¨èï¼Œçµæ´»è¿‡æ¸¡</span>
            </div>
          </template>
          <!-- L9åŒºåŸŸå§‹ç»ˆæ˜¾ç¤º -->

          <div class="stage-heroes">
            <!-- åæ’ä½ç½®æ ‡è¯† -->
            <div class="position-indicator back-row">ç»ˆ</div>
            <div v-for="hero in selectedLineup.hero_location_l9 || []"
              :key="'l9-' + (hero.chessData ? hero.chessData.chessId : 'missing-' + Math.random())" class="stage-hero"
              style="position:relative;pointer-events:auto;" v-show="!hero.chessData || hero.chessData.price !== '0'">
              <div class="stage-hero-cell"
                :class="{ 'selected': hero.chessData && isHeroSelected(hero.chessData.chessId) }"
                @click="hero.chessData && selectHero(hero.chessData)">
                <img v-if="hero.chessData" class="stage-hero-avatar"
                  :src="hero.chessData.name"
                  :alt="hero.chessData.displayName" @mouseenter="showHeroTooltip(hero.chessData, $event)"
                  @mouseleave="hideHeroTooltip" />
                <div v-else class="stage-hero-missing">å·²åˆ é™¤</div>
              </div>
              <img v-if="hero.isCore" class="icon-carry-center" src="img/icon-carry-hero.png" alt="Cä½"
                @mouseenter="showTooltipText('æ ¸å¿ƒCä½è‹±é›„', $event)" @mouseleave="hideTooltipText" />
              <div class="star-row" v-if="hero.isThreeStar" @mouseenter="showTooltipText('ä¸‰æ˜Ÿè‹±é›„', $event)"
                @mouseleave="hideTooltipText">
                <span class="icon-star" v-for="star in 3" :key="star">
                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="15" fill="none" viewBox="0 0 16 15">
                    <path fill="currentColor" fill-rule="evenodd"
                      d="m8 11.75-4.408 2.318.842-4.91L.867 5.683l4.929-.716L8 .5l2.204 4.466 4.929.716-3.566 3.477.841 4.909z"
                      clip-rule="evenodd"></path>
                  </svg>
              </div>
              <div class="equipment-list">
                <div class="component-equipment" v-for="(equip, idx) in hero.equipData" :key="idx"
                  @mouseenter="showEquipTooltip(equip, $event)" @mouseleave="hideEquipTooltip">
                  <div class="equip-pic">
                    <img :src="equip.imagePath" :alt="equip.name" />
                  </div>

                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- è£…å¤‡é¡ºåºåŒºåŸŸ -->
        <div v-if="selectedLineup && selectedLineup.equipment_order" class="lineup-equipment-section">
          <!-- æ ‡é¢˜ä¸è£…å¤‡åˆ—è¡¨å¹¶æ’ -->
          <div class="lineup-equipment-section-header">
            <!-- æ ‡é¢˜å’Œæ”»ç•¥ä¸Šä¸‹å¸ƒå±€çš„å®¹å™¨ -->
            <div class="title-strategy-container">
              <!--<div class="section-title">è£…å¤‡ä¼˜å…ˆçº§</div>-->
              <!-- è£…å¤‡æ”»ç•¥åŒºåŸŸ -->
              <div v-if="selectedLineup.equipment_info" class="equipment-strategy-section">
                <div class="equipment-strategy-hover">
                  <div class="equipment-strategy-trigger" @mouseenter="showEquipmentStrategyTooltip($event)"
                    @mouseleave="hideEquipmentStrategyTooltip">
                    <span class="equipment-strategy-text">ğŸ’¡ è£…å¤‡æ­é…</span>
                  </div>
                  <div class="equipment-strategy-tooltip" v-show="equipmentStrategyTooltipVisible">
                    {{ selectedLineup.equipment_info }}
                  </div>
                </div>
              </div>
            </div>
            <div class="equipment-order-list">
              <template v-for="(equipId, index) in getEquipmentOrder(selectedLineup.equipment_order)" :key="equipId">
                <div class="equipment-order-item" @mouseenter="showEquipTooltip(getEquipmentById(equipId), $event)"
                  @mouseleave="hideEquipTooltip">
                  <div class="equipment-priority">{{ index + 1 }}</div>
                  <div class="equipment-info" v-if="getEquipmentById(equipId)">
                    <img :src="getEquipmentById(equipId).imagePath" :alt="getEquipmentById(equipId).name"
                      class="equipment-icon" />
                  </div>
                  <div v-else class="equipment-info">
                    <div class="equipment-missing">è£…å¤‡ç¼ºå¤±</div>
                  </div>

                </div>
                <!-- è£…å¤‡ä¹‹é—´çš„ç®­å¤´ï¼Œæœ€åä¸€ä¸ªè£…å¤‡åä¸æ˜¾ç¤ºç®­å¤´ -->
                <div v-if="index < getEquipmentOrder(selectedLineup.equipment_order).length - 1"
                  class="equipment-arrow">â†’</div>
              </template>
            </div>
          </div>
        </div>

        <!-- æµ·å…‹æ–¯æ¨èåŒºåŸŸ -->
        <div v-if="selectedLineup && selectedLineup.hexbuff" class="lineup-hex-section">
          <!-- æ ‡é¢˜ä¸æµ·å…‹æ–¯åˆ—è¡¨å¹¶æ’ -->
          <div class="lineup-hex-section-header">
            <!-- æ ‡é¢˜å’Œæ”»ç•¥ä¸Šä¸‹å¸ƒå±€çš„å®¹å™¨ -->
            <div class="title-strategy-container">
              <!-- <div class="section-title">æµ·å…‹æ–¯æ¨è</div> -->
              <!-- æµ·å…‹æ–¯æ”»ç•¥åŒºåŸŸ -->
              <div v-if="selectedLineup.hex_info" class="hex-strategy-section">
                <div class="hex-strategy-hover">
                  <div class="hex-strategy-trigger" @mouseenter="showHexStrategyTooltip($event)"
                    @mouseleave="hideHexStrategyTooltip">
                    <span class="hex-strategy-text">ğŸ’¡ æµ·å…‹æ–¯æ”»ç•¥</span>
                  </div>
                  <div class="hex-strategy-tooltip" v-show="hexStrategyTooltipVisible">
                    {{ selectedLineup.hex_info }}
                  </div>
                </div>
              </div>
            </div>
            <div class="hex-content">
              <!-- æ¨èæµ·å…‹æ–¯ -->
              <div v-if="selectedLineup.hexbuff.recomm" class="hex-category">
                <div class="hex-category-title">ä¼˜å…ˆ</div>
                <div class="hex-list">
                  <div v-for="hexId in getHexList(selectedLineup.hexbuff.recomm)" :key="'recomm-' + hexId"
                    class="hex-item" @mouseenter="showHexTooltip(hexId, $event)" @mouseleave="hideHexTooltip">
                    <div class="hex-info" v-if="getHexById(hexId)">
                      <img :src="getHexById(hexId).imgUrl || getHexById(hexId).imagePath" :alt="getHexById(hexId).name"
                        class="hex-icon" />
                    </div>
                    <div v-else class="hex-info">
                      <div class="hex-missing">æµ·å…‹æ–¯ç¼ºå¤±</div>
                    </div>
                  </div>
                </div>
              </div>
              <!-- æ›¿æ¢æµ·å…‹æ–¯ -->
              <div v-if="selectedLineup.hexbuff.replace" class="hex-category">
                <div class="hex-category-title">å¤‡é€‰</div>
                <div class="hex-list">
                  <div v-for="hexId in getHexList(selectedLineup.hexbuff.replace)" :key="'replace-' + hexId"
                    class="hex-item" @mouseenter="showHexTooltip(hexId, $event)" @mouseleave="hideHexTooltip">
                    <div class="hex-info" v-if="getHexById(hexId)">
                      <img :src="getHexById(hexId).imgUrl || getHexById(hexId).imagePath" :alt="getHexById(hexId).name"
                        class="hex-icon" />
                    </div>
                    <div v-else class="hex-info">
                      <div class="hex-missing">æµ·å…‹æ–¯ç¼ºå¤±</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>


        </div>

        <!-- æ”»ç•¥ä¿¡æ¯åŒºåŸŸ -->
        <div v-if="selectedLineup && hasStrategyInfo(selectedLineup)" class="lineup-strategy-section">
          <div class="section-title" @click="toggleStrategyExpanded()">
            <span>é˜µå®¹æ”»ç•¥</span>
            <span class="strategy-toggle-icon" :class="{ 'expanded': strategyExpanded }">
              {{ strategyExpanded ? 'â–¼' : 'â–¶' }}
            </span>
          </div>

          <!-- æ”»ç•¥å†…å®¹åŒºåŸŸ - å¯å±•å¼€æ”¶èµ· -->
          <div v-show="strategyExpanded" class="strategy-content-wrapper">
            <!-- Dç‰Œæ—¶æœº -->
            <div v-if="selectedLineup.d_time" class="strategy-item">
              <div class="strategy-label">Dç‰Œæ—¶æœº</div>
              <div class="strategy-content">{{ selectedLineup.d_time }}</div>
            </div>

            <!-- å¯¹å±€åˆ†æ -->
            <div v-if="selectedLineup.enemy_info" class="strategy-item">
              <div class="strategy-label">å¯¹å±€åˆ†æ</div>
              <div class="strategy-content">{{ selectedLineup.enemy_info }}</div>
            </div>
          </div>
        </div>

        <!-- æ¨èå¤©é€‰è‹±é›„åŒºåŸŸ -->
        <div v-if="selectedLineup && hasChosenHeroInfo()" class="chosen-hero-section">
          <div class="section-title" @click="toggleChosenHeroExpanded()">
            <span>æ¨èèµ›å­£ä¹‹æ˜Ÿ</span>
            <span class="strategy-toggle-icon" :class="{ 'expanded': chosenHeroExpanded }">
              {{ chosenHeroExpanded ? 'â–¼' : 'â–¶' }}
            </span>
          </div>

          <!-- æ¨èå¤©é€‰è‹±é›„å†…å®¹åŒºåŸŸ - å¯å±•å¼€æ”¶èµ· -->
          <div v-show="chosenHeroExpanded" class="chosen-hero-content">
            <!-- å‰æœŸæ¨èå¤©é€‰ -->
            <div v-if="getChosenHeroData('early').length > 0" class="chosen-hero-stage">
              <div class="chosen-hero-stage-title">

                <span>å‰æœŸä¼˜é€‰</span>
              </div>
              <div class="chosen-hero-list">
                <div v-for="hero in getChosenHeroData('early')" :key="'early-' + hero.id" class="chosen-hero-item"
                  @mouseenter="showHeroTooltip(getHeroById(hero.id), $event)" @mouseleave="hideHeroTooltip">
                  <div class="chosen-hero-avatar-container">
                    <img class="chosen-hero-avatar"
                      :src="hero.imagePath"
                      :alt="hero.name" />

                  </div>
                  <div class="chosen-hero-info">
                    <div class="chosen-hero-name">{{ (getHeroById(hero.id) && getHeroById(hero.id).displayName) ||
                      (getHeroById(hero.id) && getHeroById(hero.id).name) }}</div>
                    <div v-if="hero.synergy" class="chosen-hero-synergy">{{ hero.synergy.name }}</div>
                  </div>
                </div>
              </div>
            </div>

            <!-- ä¸­æœŸæ¨èå¤©é€‰ -->
            <div v-if="getChosenHeroData('middle').length > 0" class="chosen-hero-stage">
              <div class="chosen-hero-stage-title">

                <span>ä¸­æœŸä¼˜é€‰</span>
              </div>
              <div class="chosen-hero-list">
                <div v-for="hero in getChosenHeroData('middle')" :key="'middle-' + hero.id" class="chosen-hero-item"
                  @mouseenter="showHeroTooltip(getHeroById(hero.id), $event)" @mouseleave="hideHeroTooltip">
                  <div class="chosen-hero-avatar-container">
                    <img class="chosen-hero-avatar"
                      :src=" hero.imagePath"
                      :alt="hero.name" />

                  </div>
                  <div class="chosen-hero-info">
                    <div class="chosen-hero-name">{{ (getHeroById(hero.id) && getHeroById(hero.id).displayName) ||
                      (getHeroById(hero.id) && getHeroById(hero.id).name) }}</div>
                    <div v-if="hero.synergy" class="chosen-hero-synergy">{{ hero.synergy.name }}</div>
                  </div>
                </div>
              </div>
            </div>

            <!-- åæœŸæ¨èå¤©é€‰ -->
            <div v-if="getChosenHeroData('late').length > 0" class="chosen-hero-stage">
              <div class="chosen-hero-stage-title">

                <span>åæœŸä¼˜é€‰</span>
              </div>
              <div class="chosen-hero-list">
                <div v-for="hero in getChosenHeroData('late')" :key="'late-' + hero.id" class="chosen-hero-item"
                  @mouseenter="showHeroTooltip(getHeroById(hero.id), $event)" @mouseleave="hideHeroTooltip">
                  <div class="chosen-hero-avatar-container">
                    <img class="chosen-hero-avatar"
                      :src="hero.imagePath"
                      :alt="hero.name" />

                  </div>
                  <div class="chosen-hero-info">
                    <div class="chosen-hero-name">{{ (getHeroById(hero.id) && getHeroById(hero.id).displayName) ||
                      (getHeroById(hero.id) && getHeroById(hero.id).name) }}</div>
                    <div v-if="hero.synergy" class="chosen-hero-synergy">{{ hero.synergy.name }}</div>
                  </div>
                </div>
              </div>
            </div>

            <!-- æ›¿æ¢æ¨èå¤©é€‰ -->
            <div v-if="getChosenHeroData('replace').length > 0" class="chosen-hero-stage">
              <div class="chosen-hero-stage-title">

                <span>åæœŸå¤‡é€‰</span>
              </div>
              <div class="chosen-hero-list">
                <div v-for="hero in getChosenHeroData('replace')" :key="'replace-' + hero.id" class="chosen-hero-item"
                  @mouseenter="showHeroTooltip(getHeroById(hero.id), $event)" @mouseleave="hideHeroTooltip">
                  <div class="chosen-hero-avatar-container">
                    <img class="chosen-hero-avatar"
                      :src="hero.imagePath"
                      :alt="hero.name" />

                  </div>
                  <div class="chosen-hero-info">
                    <div class="chosen-hero-name">{{ (getHeroById(hero.id) && getHeroById(hero.id).displayName) ||
                      (getHeroById(hero.id) && getHeroById(hero.id).name) }}</div>
                    <div v-if="hero.synergy" class="chosen-hero-synergy">{{ hero.synergy.name }}</div>
                  </div>
                </div>
              </div>
            </div>

            <!-- æ— æ•°æ®æç¤º -->
            <div
              v-if="getChosenHeroData('early').length === 0 && getChosenHeroData('middle').length === 0 && getChosenHeroData('late').length === 0 && getChosenHeroData('replace').length === 0"
              class="chosen-hero-empty">
              <div class="empty-icon">ğŸ“‹</div>
              <div class="empty-text">æš‚æ— æ¨èå¤©é€‰è‹±é›„æ•°æ®</div>
            </div>
          </div>
        </div>

        <!-- å¯æ›¿æ¢è‹±é›„åŒºåŸŸ -->
        <div v-if="selectedLineup && hasReplaceableHeroes()" class="replaceable-heroes-section">
          <div class="section-title" @click="toggleReplaceableHeroesExpanded()">
            <span>å¯æ›¿æ¢è‹±é›„</span>
            <span class="strategy-toggle-icon" :class="{ 'expanded': replaceableHeroesExpanded }">
              {{ replaceableHeroesExpanded ? 'â–¼' : 'â–¶' }}
            </span>
          </div>

          <!-- å¯æ›¿æ¢è‹±é›„å†…å®¹åŒºåŸŸ - å¯å±•å¼€æ”¶èµ· -->
          <div v-show="replaceableHeroesExpanded" class="replaceable-heroes-content">
            <div v-for="(group, index) in getReplaceableHeroGroups()" :key="'replace-group-' + index"
              class="replaceable-hero-group">

              <div class="replaceable-hero-list">
                <!-- åŸè‹±é›„ -->
                <div class="replaceable-hero-original">
                  <div class="replaceable-hero-label">åŸè‹±é›„:</div>
                  <div class="replaceable-heroes-container">
                    <div v-for="heroId in group.original" :key="'original-' + heroId" class="replaceable-hero-item"
                      @mouseenter="showHeroTooltip(getHeroById(heroId), $event)" @mouseleave="hideHeroTooltip()">
                      <div class="replaceable-hero-cell">
                        <img v-if="getHeroById(heroId)" class="replaceable-hero-avatar"
                          :src="getHeroById(heroId).name"
                          :alt="getHeroById(heroId).name" />
                        <div v-else class="replaceable-hero-missing">æœªæ‰¾åˆ°</div>
                      </div>
                      <div class="replaceable-hero-info">
                        <div class="replaceable-hero-name">{{ (getHeroById(heroId) && getHeroById(heroId).displayName)
                          || (getHeroById(heroId) && getHeroById(heroId).name) || 'æœªçŸ¥è‹±é›„' }}</div>
                      </div>
                    </div>
                  </div>
                </div>

                <!-- ç®­å¤´ -->
                <div class="replaceable-arrow">â†’</div>

                <!-- æ›¿æ¢è‹±é›„ -->
                <div class="replaceable-hero-replacement">
                  <div class="replaceable-hero-label">å¯æ›¿æ¢ä¸º:</div>
                  <div class="replaceable-heroes-container">
                    <div v-for="heroId in group.replacement" :key="'replacement-' + heroId"
                      class="replaceable-hero-item" @mouseenter="showHeroTooltip(getHeroById(heroId), $event)"
                      @mouseleave="hideHeroTooltip()">
                      <div class="replaceable-hero-cell">
                        <img v-if="getHeroById(heroId)" class="replaceable-hero-avatar"
                          :src="getHeroById(heroId).name"
                          :alt="getHeroById(heroId).name" />
                        <div v-else class="replaceable-hero-missing">æœªæ‰¾åˆ°</div>
                      </div>
                      <div class="replaceable-hero-info">
                        <div class="replaceable-hero-name">{{ (getHeroById(heroId) && getHeroById(heroId).displayName)
                          || (getHeroById(heroId) && getHeroById(heroId).name) || 'æœªçŸ¥è‹±é›„' }}</div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- æ— æ•°æ®æç¤º -->
            <div v-if="!hasReplaceableHeroes()" class="replaceable-heroes-empty">
              <div class="empty-icon">ğŸ”„</div>
              <div class="empty-text">æš‚æ— å¯æ›¿æ¢è‹±é›„æ•°æ®</div>
            </div>
          </div>
        </div>

      </div>
    </div>

    <div v-if="loading" class="loading-container">
      <div class="loading-hexagon"></div>
      <div class="loading-text-container">
        <span class="loading-text">{{ loadingMessage }}</span>
        <span class="loading-dots" v-if="loadingProgress < 100">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </span>
      </div>
      <div class="loading-progress">
        <div class="progress-bar" :style="{ width: loadingProgress + '%' }"></div>
      </div>
      <div class="progress-percentage">{{ loadingProgress }}%</div>
    </div>

    <!-- èµ›å­£é€‰æ‹©å™¨ -->
    <div v-if="showSeasonSelector" class="season-selector-overlay">
      <div class="season-selector-dialog">
        <div class="season-selector-header">
          <h3>é€‰æ‹©æ¸¸æˆèµ›å­£</h3>
          <p>æ£€æµ‹åˆ°å¤šä¸ªèµ›å­£æ•°æ®ï¼Œè¯·é€‰æ‹©è¦ä½¿ç”¨çš„èµ›å­£ï¼š</p>
        </div>

        <div class="season-options">
          <div v-for="season in availableSeasons" :key="season.key" class="season-option"
            :class="{ 'selected': selectedSeason === season.key }" @click="selectedSeason = season.key">
            <div class="season-option-radio">
              <span v-if="selectedSeason === season.key" class="radio-checked"></span>
            </div>
            <div class="season-option-content">
              <div class="season-name">{{ season.name }}</div>
              <div class="season-description">
                {{ season.key === 'current' ? 'å½“å‰èµ›å­£' : 'è½®æ¢èµ›å­£' }}
              </div>
            </div>
          </div>
        </div>

        <div class="season-selector-buttons">
          <button class="season-confirm-btn" @click="confirmSeasonSelection" :disabled="!selectedSeason">
            ç¡®è®¤é€‰æ‹©
          </button>
        </div>
      </div>
    </div>





    <!-- é˜µå®¹äºŒçº§èœå•ï¼ˆdata-lineupï¼‰ -->
    <div class="data-lineup center-panel" v-if="topMenu==='lineup'">
      <!-- æ ‡ç­¾é¡µåˆ‡æ¢ç»„ä»¶ -->
      <div class="tab-container" style="position:relative;">
        <!-- å…³é—­æŒ‰é’® -->
        <button class="lineup-close-btn" @click="toggleTopMenu('lineup')" title="å…³é—­">Ã—</button>
        <div class="tab-header">
          <div class="tab" :class="{active: activeTab === 'opgg'}" @click="switchTab('opgg')">
            OP.GG
          </div>
          <div class="tab" :class="{active: activeTab === 'tft'}" @click="switchTab('tft')">
            å®˜æ–¹
          </div>
          <div class="tab" :class="{active: activeTab === 'favorite'}" @click="switchTab('favorite')">
            æ”¶è—
            <span v-if="favoriteLineups.length > 0" class="favorite-count">({{ favoriteLineups.length }})</span>
          </div>

          <!-- æœç´¢æ¡†ç»„ä»¶ -->
          <div class="search-container">
            <input type="text" class="search-input" placeholder="æ”¯æŒè‹±é›„`åç§°`å¤–å·`æ‹¼éŸ³`é¦–æ‹¼`é˜µå®¹æ ‡é¢˜..." v-model="searchText" />


            <!-- ç­›é€‰æŒ‰é’® -->
            <button class="filter-toggle-button" @click="toggleFilterPanel($event)" title="ç­›é€‰èŒä¸šç¾ç»Šä»¥åŠç­‰çº§">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="4" y1="21" x2="4" y2="14"></line>
                <line x1="4" y1="10" x2="4" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="12"></line>
                <line x1="12" y1="8" x2="12" y2="3"></line>
                <line x1="20" y1="21" x2="20" y2="16"></line>
                <line x1="20" y1="12" x2="20" y2="3"></line>
                <line x1="1" y1="14" x2="7" y2="14"></line>
                <line x1="9" y1="8" x2="15" y2="8"></line>
                <line x1="17" y1="16" x2="23" y2="16"></line>
              </svg>
            </button>

            <!-- é‡ç½®æŒ‰é’® -->
            <button class="reset-search-button" @click="resetSearch" title="é‡ç½®æœç´¢ä»¥åŠç­›é€‰">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 12a9 9 0 0 1-9 9c-4.97 0-9-4.03-9-9s4.03-9 9-9h4.5"></path>
                <polyline points="15 3 21 3 21 9"></polyline>
                <line x1="21" y1="3" x2="9" y2="15"></line>
              </svg>
            </button>
          </div>
        </div>

        <!-- æ ‡ç­¾å†…å®¹ -->
        <div class="tab-content">
          <!-- æ”¶è—å­˜å‚¨ä½¿ç”¨æƒ…å†µæ˜¾ç¤º -->


          <!-- æ”¶è—èµ›å­£ä¿¡æ¯æ˜¾ç¤º -->
          <div v-if="activeTab === 'favorite'" class="season-info-panel">
            <div class="season-info-content">
              <span class="season-text">å½“å‰èµ›å­£ï¼š{{ getCurrentSeason() || 'æœªçŸ¥' }}</span>
              <span class="season-text2" v-if="!showAllFavorites">ä¸æ˜¯å½“å‰èµ›å­£çš„æ”¶è—é˜µå®¹å°†ä¸ä¼šæ˜¾ç¤º</span>
              <span class="season-text2" v-if="showAllFavorites" style="color: #00ff00;">æ­£åœ¨æ˜¾ç¤ºå…¨éƒ¨æ”¶è—é˜µå®¹ï¼ˆåŒ…å«æ‰€æœ‰èµ›å­£ï¼‰</span>
              <span class="season-count">æ˜¾ç¤º {{ currentLineupList.length }} / {{ favoriteLineups.length }} ä¸ªæ”¶è—é˜µå®¹</span>
              <button class="show-all-favorites-btn" @click="toggleShowAllFavorites"
                :title="showAllFavorites ? 'åªæ˜¾ç¤ºå½“å‰èµ›å­£' : 'æ˜¾ç¤ºå…¨éƒ¨æ”¶è—é˜µå®¹'">
                {{ showAllFavorites ? 'åªæ˜¾ç¤ºå½“å‰èµ›å­£' : 'æ˜¾ç¤ºå…¨éƒ¨æ”¶è—' }}
              </button>
            </div>
          </div>

          <!-- é˜µå®¹å†…å®¹ï¼ˆä½¿ç”¨è®¡ç®—å±æ€§ç»Ÿä¸€å¤„ç†ï¼‰ -->
          <div class="tab-pane">
            <div v-if="currentLineupList && currentLineupList.length" class="lineup-list">
              <div v-for="(lineup, index) in filteredLineups" :key="activeTab + '-' + index" class="lineup-item" :class="{ 
                    'outdated': lineup.isOld, 
                    'has-invalid-heroes': lineup.hasInvalidHeroes 
                  }" @click="lineup.hasInvalidHeroes ? null : selectLineup(lineup)">
                <!-- æ”¶è—æŒ‰é’® -->
                <button class="favorite-btn" :class="{ 'favorited': isLineupFavorited(lineup) }"
                  @click.stop="toggleFavorite(lineup)" :title="isLineupFavorited(lineup) ? 'å–æ¶ˆæ”¶è—' : 'æ”¶è—é˜µå®¹'">
                  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path
                      d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z">
                    </path>
                  </svg>
                </button>

                <div class="lineup-container">
                  <div class="lineup-quality" :class="'quality-' + lineup.quality.toLowerCase()">
                    <img :src="'./img/icon-tier-' + lineup.quality + '.webp'" :alt="lineup.quality"
                      class="quality-icon" />
                    <!-- æ·»åŠ ä»·æ ¼ç»Ÿè®¡ -->
                    <div class="lineup-price" v-if="lineup.hero_location_l9 && lineup.hero_location_l9.length">
                      <i class="hero-price-img"></i>
                      {{ lineup.hero_location_l9.filter(h => !h.chessData || h.chessData.price !== '0').reduce((total,
                      hero) => {
                      const price = hero.chessData && hero.chessData.price ?
                      parseInt(hero.chessData.price) : 0; return total + price
                      * (hero.unit && hero.unit.isThreeStar ? 9 : 3); }, 0) }}
                    </div>

                  </div>
                  <div class="lineup-content">
                    <div class="lineup-name">
                      {{ lineup.name }}
                      <span class="lineup-stats"
                        v-if="lineup.avgPlacement || lineup.pickRate || lineup.top4Rate || lineup.winRate">
                        <span v-if="lineup.avgPlacement" class="stat-item">å¹³å‡æ’å: {{ lineup.avgPlacement }}</span>
                        <span v-if="lineup.pickRate" class="stat-item">ä½¿ç”¨ç‡: {{ lineup.pickRate }}</span>
                        <span v-if="lineup.top4Rate" class="stat-item">å‰å››ç‡: {{ lineup.top4Rate }}</span>
                        <span v-if="lineup.winRate" class="stat-item">ç¬¬ä¸€ç‡: {{ lineup.winRate }}</span>
                      </span>
                    </div>
                    <!-- æ·»åŠ è‹±é›„å±•ç¤º -->
                    <div class="lineup-heroes" v-if="lineup.hero_location_l9 && lineup.hero_location_l9.length">
                      <div
                        v-for="(hero, heroIndex) in lineup.hero_location_l9.filter(h => !h.chessData || h.chessData.price !== '0').slice(0, 9)"
                        :key="'hero-'+heroIndex" class="lineup-hero">
                        <!-- ä¸‰æ˜Ÿæ ‡è®°è¡Œ - åªæœ‰å½“é˜µå®¹ä¸­è‡³å°‘æœ‰ä¸€ä¸ªè‹±é›„æ˜¯ä¸‰æ˜Ÿæ—¶æ‰æ˜¾ç¤º -->
                        <div class="hero-threestar-row"
                          v-if="lineup.hero_location_l9.filter(h => !h.chessData || h.chessData.price !== '0').some(h => h.isThreeStar)">
                          <div v-if="hero.isThreeStar" class="hero-star-icon" v-for="star in 3" :key="star">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="15" fill="none"
                              viewBox="0 0 16 15">
                              <path fill="currentColor" fill-rule="evenodd"
                                d="m8 11.75-4.408 2.318.842-4.91L.867 5.683l4.929-.716L8 .5l2.204 4.466 4.929.716-3.566 3.477.841 4.909z"
                                clip-rule="evenodd"></path>
                            </svg>
                          </div>
                        </div>
                        <!-- è‹±é›„1å›¾ç‰‡1å®¹å™¨1 -->
                        <div class="lineup-hero-image-container">
                          <img v-if="hero.chessData"
                            :src="hero_avatar_xiao.replace('{{name}}', hero.chessData.name || hero.chessData.chessId + '.png')"
                            :alt="hero.chessData.displayName" class="lineup-hero-image"
                            @mouseenter="showHeroTooltip(hero.chessData, $event)" @mouseleave="hideHeroTooltip" />
                          <div v-else class="lineup-hero-missing">
                            <span>è‹±é›„å·²åˆ é™¤</span>
                          </div>
                          <div class="lineup-hero-img-name">{{ hero.chessData ? hero.chessData.displayName : 'å·²åˆ é™¤' }}
                          </div>
                          <!-- Cä½å›¾æ ‡ -->
                          <img v-if="hero.isCore && hero.chessData" src="./img/icon-carry-hero.png" alt="Cä½"
                            class="hero-core-icon" @mouseenter="showTooltipText('æ ¸å¿ƒCä½è‹±é›„', $event)"
                            @mouseleave="hideTooltipText" />
                        </div>
                        <!-- è£…å¤‡æ  -->
                        <div class="hero-items-row" v-if="hero.chessData">
                          <div v-for="slot in 3" :key="slot" class="hero-item-slot">
                            <img v-if="hero.equipData && hero.equipData[slot-1]" :src="hero.equipData[slot-1].imagePath"
                              :alt="hero.equipData[slot-1].name" class="hero-item-image"
                              @mouseenter="showEquipTooltip(hero.equipData[slot-1], $event)"
                              @mouseleave="hideEquipTooltip" />
                          </div>
                        </div>
                      </div>
                      <div
                        v-if="lineup.hero_location_l9.filter(h => !h.chessData || h.chessData.price !== '0').length > 9"
                        class="lineup-hero-more">
                        +{{ lineup.hero_location_l9.filter(h => !h.chessData || h.chessData.price !== '0').length - 9 }}
                      </div>
                    </div>

                  </div>
                </div>
              </div>
            </div>
            <div v-else class="no-data">
              <p>æš‚æ— {{ activeTab === 'opgg' ? 'OP.GG' : activeTab === 'tft' ? 'å®˜æ–¹' : 'æ”¶è—' }}é˜µå®¹æ•°æ®</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div v-if="!loading" class="avatar-mode-container">
      <div v-for="price in [1,2,3,4,5]" :key="'row-'+price" class="avatar-row">
        <!-- è´¹ç”¨æ ‡è¯†å°æ¡† -->
        <div class="cost-indicator" :class="'cost-' + price">
          {{ price }}
        </div>
        <div class="avatar-row-list">
          <div v-for="hero in heroDataList.filter(h=>parseInt(h.price)===price)" :key="hero.chessId" class="avatar-cell"
            :class="{ 'selected': isHeroSelected(hero.chessId) }" @click.stop="toggleHeroSelection(hero)"
            @mouseenter="showHeroTooltip(hero, $event)" @mouseleave="hideHeroTooltip">
            <img :src="hero_avatar_xiao.replace('{{name}}', hero.name || hero.chessId + '.png')" :alt="hero.displayName"
              class="avatar-img" />
          </div>
        </div>
      </div>
      <!-- æ‚¬æµ®æ¡†æµ®å±‚ -->
      <div v-if="tooltipVisible && tooltipHero" class="hero-tooltip"
        :style="{left: tooltipX + 'px', top: tooltipY + 'px', visibility: 'visible', opacity: 1, position: 'fixed', zIndex: 2000}">
        <!-- position-panelç®€åŒ–æ˜¾ç¤ºï¼šåªæ˜¾ç¤ºå¤´åƒã€åå­—å’Œé‡‘å¸ -->
        <template v-if="isPositionPanelTooltip">
          <div class="hero-tooltip-header">
            <img :src="hero_avatar_xiao.replace('{{name}}', tooltipHero.name || tooltipHero.chessId + '.png')"
              :alt="tooltipHero.displayName" class="hero-tooltip-image" :class="'price-tooltip-' + tooltipHero.price" />
            <div class="hero-tooltip-info">
              <div class="hero-tooltip-name-row">
                <div class="hero-tooltip-title">{{ tooltipHero.title }}</div>
                <div class="hero-tooltip-name">{{ tooltipHero.displayName }}</div>
              </div>
              <div class="hero-tooltip-price">
                <i class="hero-price-img2"></i>
                {{ tooltipHero.price }}
              </div>
            </div>
          </div>
        </template>

        <!-- æ™®é€šè‹±é›„å®Œæ•´æ˜¾ç¤º -->
        <template v-else>
          <div class="hero-tooltip-header">
            <img :src="hero_avatar_xiao.replace('{{name}}', tooltipHero.name || tooltipHero.chessId + '.png')"
              :alt="tooltipHero.displayName" class="hero-tooltip-image" :class="'price-tooltip-' + tooltipHero.price" />
            <div class="hero-tooltip-info">
              <div class="hero-tooltip-name-row">
                <div class="hero-tooltip-title">{{ tooltipHero.title }}</div>
                <div class="hero-tooltip-name">{{ tooltipHero.displayName }}</div>
              </div>
              <div class="hero-tooltip-price">
                <i class="hero-price-img2"></i>
                {{ tooltipHero.price }}
              </div>
            </div>
          </div>
          <div class="tooltip-layout-container">
            <!-- ä¿®æ”¹ä¸ºè¡Œå†…ç´§å‡‘æ˜¾ç¤ºç»“æ„ -->
            <div class="tooltip-left-column">
              <!-- ç¾ç»ŠåŒºåŸŸ -->
              <div class="hero-traits">
                <!-- ç§æ—ç¾ç»Š -->
                <div v-for="race in tooltipHero.raceId" :key="'race-'+race.raceId" class="hero-trait-row">
                  <div class="hero-trait-item">
                    <img :src="race.imagePath" :alt="race.name" class="trait-icon" />
                    <span class="trait-name">{{ race.name }}</span>
                  </div>
                </div>
                <!-- èŒä¸šç¾ç»Š -->
                <div v-for="job in tooltipHero.jobId" :key="'job-'+job.jobId" class="hero-trait-row">
                  <div class="hero-trait-item">
                    <img :src="job.imagePath" :alt="job.name" class="trait-icon" />
                    <span class="trait-name">{{ job.name }}</span>
                  </div>
                </div>
              </div>

              <!-- æ”»å‡»èŒƒå›´ -->
              <div class="hero-rating-container">
                <div class="hero-rating-title">æ”»å‡»èŒƒå›´</div>
                <div class="hero-rating-dots">
                  <span v-for="n in 5" :key="n"
                    :class="['hero-rating-dot', { active: n <= tooltipHero.attackRange }]"></span>
                </div>
              </div>
            </div>
          </div>
          <div class="tooltip-divider"></div>
          <div class="skill-info-container">
            <div class="skill-icon-container">
              <img :src="tooltipHero.skillImage" :alt="tooltipHero.displayName" class="hero-tooltip-skill-image" />
            </div>
            <div class="skill-details-container">
              <div class="skill-name-container">
                <div class="hero-tooltip-skill-Name">{{ tooltipHero.skillName }}</div>
              </div>
              <div class="skill-bottom-row">
                <div class="skill-type-container">
                  <div class="hero-tooltip-skill-Type">{{ tooltipHero.skillType }}</div>
                </div>
                <div class="skill-mana-container">
                  <img src="./img/Mana.webp" class="hero-tooltip-skill-lan" />
                  <div class="hero-tooltip-skill-startMagic">{{ tooltipHero.startMagic || 0 }}</div>
                  <div class="hero-tooltip-skill-xiegang">\</div>
                  <div class="hero-tooltip-skill-magic">{{ tooltipHero.magic || 0 }}</div>
                </div>
              </div>
            </div>
          </div>
          <div class="tooltip-divider"></div>
          <div class="hero-tooltip-skill-Detail">{{ tooltipHero.skillDetail }}</div>
          <div class="tooltip-divider"></div>
          <div v-if="tooltipHero.equipId && tooltipHero.equipId.length" class="hero-tooltip-Item">
            <div class="hero-tooltip-Item-title">æ¨èè£…å¤‡</div>
            <div class="recommended-items-container">
              <div v-for="item in tooltipHero.equipId" :key="item.equipId" class="recommended-item">
                <img :src="item.imagePath" :alt="'è£…å¤‡ ' + item.equipId" class="recommended-item-image" />
                <div class="equip-tooltip" v-if="item.formula">
                  <div v-for="(formula, idx) in item.formula.split(',')" :key="idx" class="formula-item">
                    <img :src="getEquipImage(formula)" :alt="'è£…å¤‡ ' + formula" class="formula-image" />
                  </div>
                </div>
                <div class="hero-tooltip-Item-name">{{ item.name }}</div>
              </div>
            </div>
          </div>
        </template>
      </div>
    </div>
    <div v-else>
    </div>

    <!-- åŠŸèƒ½èœå•å®¹å™¨ï¼Œæ ·å¼ä¸data-lineupä¸€è‡´ -->
    <div v-if="topMenu==='feature'" class="feature-menu-panel">
      <div class="feature-menu-content">
        <!-- å…³é—­æŒ‰é’® -->
        <button class="lineup-close-btn" @click="toggleTopMenu('feature')" title="å…³é—­åŠŸèƒ½èœå•">Ã—</button>

        <!-- åŠŸèƒ½èœå•æ ‡é¢˜ -->
        <div class="feature-menu-header">
          <h3>åŠŸèƒ½èœå•</h3>
        </div>

        <!-- å·¦å³åˆ†æ å¸ƒå±€ -->
        <div class="feature-menu-layout">
          <!-- å·¦ä¾§å¯¼èˆªèœå• -->
          <div class="feature-nav">
            <div class="feature-nav-item" :class="{ active: activeFeatureTab === 'favorites' }"
              @click="activeFeatureTab = 'favorites'">
              <span class="nav-icon">ğŸ’¾</span>
              <span class="nav-text">æ”¶è—ç®¡ç†</span>
            </div>
            <div class="feature-nav-item" :class="{ active: activeFeatureTab === 'data' }"
              @click="activeFeatureTab = 'data'">
              <span class="nav-icon">ğŸ—„ï¸</span>
              <span class="nav-text">æ•°æ®ç®¡ç†</span>
            </div>
            <div class="feature-nav-item" :class="{ active: activeFeatureTab === 'settings' }"
              @click="activeFeatureTab = 'settings'">
              <span class="nav-icon">âš™ï¸</span>
              <span class="nav-text">æ˜¾ç¤ºè®¾ç½®</span>
            </div>
            <div class="feature-nav-item" :class="{ active: activeFeatureTab === 'tools' }"
              @click="activeFeatureTab = 'tools'">
              <span class="nav-icon">ğŸ› ï¸</span>
              <span class="nav-text">å®ç”¨å·¥å…·</span>
            </div>
            <div class="feature-nav-item" :class="{ active: activeFeatureTab === 'help' }"
              @click="activeFeatureTab = 'help'">
              <span class="nav-icon">â“</span>
              <span class="nav-text">å¸®åŠ©ä¿¡æ¯</span>
            </div>
          </div>

          <!-- å³ä¾§å†…å®¹åŒºåŸŸ -->
          <div class="feature-content">
            <!-- æ”¶è—ç®¡ç†å†…å®¹ -->
            <div v-if="activeFeatureTab === 'favorites'" class="feature-content-panel">
              <h4 class="content-title">æ”¶è—ç®¡ç†</h4>
              <div class="feature-buttons">
                <button class="feature-btn" @click="exportFavorites" title="å°†æ”¶è—æ•°æ®å¯¼å‡ºä¸ºJSONæ–‡ä»¶">
                  <span class="btn-icon">ğŸ“¤</span>
                  <span class="btn-text">å¯¼å‡ºæ”¶è—</span>
                  <span class="btn-desc">ä¿å­˜æ”¶è—åˆ°æœ¬åœ°æ–‡ä»¶</span>
                </button>
                <button class="feature-btn" @click="importFavorites" title="ä»JSONæ–‡ä»¶å¯¼å…¥æ”¶è—æ•°æ®">
                  <span class="btn-icon">ğŸ“¥</span>
                  <span class="btn-text">å¯¼å…¥æ”¶è—</span>
                  <span class="btn-desc">ä»æ–‡ä»¶æ¢å¤æ”¶è—æ•°æ®</span>
                </button>
                <button class="feature-btn" @click="cleanOutdatedFavorites" title="æ¸…ç†åŒ…å«å·²åˆ é™¤è‹±é›„çš„æ”¶è—">
                  <span class="btn-icon">ğŸ§¹</span>
                  <span class="btn-text">æ¸…ç†æ”¶è—</span>
                  <span class="btn-desc">ç§»é™¤è¿‡æ—¶çš„æ”¶è—é˜µå®¹</span>
                </button>
              </div>

              <!-- å­˜å‚¨ä½¿ç”¨æƒ…å†µ -->
              <div class="storage-info" v-if="favoriteLineups.length > 0">
                <div class="storage-header">
                  <span class="storage-icon">ğŸ“Š</span>
                  <span class="storage-title">å­˜å‚¨ä½¿ç”¨æƒ…å†µ</span>
                </div>
                <div class="storage-details">
                  <div class="storage-item">
                    <span class="storage-label">æ”¶è—æ•°é‡:</span>
                    <span class="storage-value">{{ favoriteLineups.length }} ä¸ªé˜µå®¹</span>
                  </div>
                  <div class="storage-item">
                    <span class="storage-label">å­˜å‚¨å¤§å°:</span>
                    <span class="storage-value">{{ getStorageInfo().sizeMB }}MB / 4MB</span>
                  </div>
                  <div class="storage-item">
                    <span class="storage-label">ä½¿ç”¨ç‡:</span>
                    <span class="storage-value">{{ getStorageInfo().usagePercent }}%</span>
                  </div>
                </div>
                <div class="storage-progress-bar">
                  <div class="storage-progress-fill" :style="{ width: getStorageInfo().usagePercent + '%' }"></div>
                </div>
              </div>
              <div v-else class="no-favorites">
                <span class="no-data-icon">ğŸ“­</span>
                <p>æš‚æ— æ”¶è—æ•°æ®</p>
                <p class="no-data-tip">æ”¶è—ä¸€äº›é˜µå®¹åï¼Œè¿™é‡Œå°†æ˜¾ç¤ºå­˜å‚¨ä¿¡æ¯</p>
              </div>
            </div>

            <!-- æ•°æ®ç®¡ç†å†…å®¹ -->
            <div v-if="activeFeatureTab === 'data'" class="feature-content-panel">
              <h4 class="content-title">æ•°æ®ç®¡ç†</h4>
              <div class="feature-buttons">
                <button class="feature-btn" @click="reloadData" title="é‡æ–°åŠ è½½æ¸¸æˆæ•°æ®">
                  <span class="btn-icon">ğŸ”„</span>
                  <span class="btn-text">é‡æ–°åŠ è½½</span>
                  <span class="btn-desc">åˆ·æ–°æ‰€æœ‰æ¸¸æˆæ•°æ®</span>
                </button>
                <button class="feature-btn" @click="clearCache" title="æ¸…é™¤æœ¬åœ°ç¼“å­˜æ•°æ®">
                  <span class="btn-icon">ğŸ—‘ï¸</span>
                  <span class="btn-text">æ¸…é™¤ç¼“å­˜</span>
                  <span class="btn-desc">æ¸…ç†ä¸´æ—¶æ•°æ®ï¼Œä¿ç•™æ”¶è—</span>
                </button>
                <button class="feature-btn" @click="showSeasonInfo" title="æŸ¥çœ‹å½“å‰èµ›å­£ä¿¡æ¯">
                  <span class="btn-icon">â„¹ï¸</span>
                  <span class="btn-text">èµ›å­£ä¿¡æ¯</span>
                  <span class="btn-desc">æŸ¥çœ‹å½“å‰èµ›å­£è¯¦ç»†ä¿¡æ¯</span>
                </button>
              </div>

              <!-- æ•°æ®ç»Ÿè®¡ä¿¡æ¯ -->
              <div class="data-stats">
                <div class="stats-header">
                  <span class="stats-icon">ğŸ“ˆ</span>
                  <span class="stats-title">æ•°æ®ç»Ÿè®¡</span>
                </div>
                <div class="stats-grid">
                  <div class="stat-item">
                    <div class="stat-number">{{ Data.current.TFTChampionData ? Data.current.TFTChampionData.length : 0
                      }}</div>
                    <div class="stat-label">è‹±é›„æ•°é‡</div>

                  </div>
                  <div class="stat-item">
                    <div class="stat-number">{{ ((Data.current.OPGLineupList && Data.current.OPGLineupList.length) || 0)
                      +
                      ((Data.current.TFTLineupList && Data.current.TFTLineupList.length) || 0) }}</div>
                    <div class="stat-label">é˜µå®¹æ•°é‡</div>

                  </div>
                  <div class="stat-item">
                    <div class="stat-number">{{ Data.current.TFTEquipData ? Data.current.TFTEquipData.length : 0 }}
                    </div>
                    <div class="stat-label">è£…å¤‡æ•°é‡</div>

                  </div>
                  <div class="stat-item">
                    <div class="stat-number">{{ favoriteLineups.length }}</div>
                    <div class="stat-label">æ”¶è—æ•°é‡</div>

                  </div>
                </div>
              </div>
            </div>

            <!-- æ˜¾ç¤ºè®¾ç½®å†…å®¹ -->
            <div v-if="activeFeatureTab === 'settings'" class="feature-content-panel">
              <h4 class="content-title">æ˜¾ç¤ºè®¾ç½®</h4>
              <div class="settings-list">
                <div class="setting-item">
                  <div class="setting-info">
                    <div class="setting-name">æ˜¾ç¤ºè‹±é›„åç§°</div>
                    <div class="setting-desc">åœ¨è‹±é›„å¤´åƒä¸‹æ–¹æ˜¾ç¤ºåç§°</div>

                  </div>
                  <label class="setting-toggle">
                    <input type="checkbox" v-model="showHeroNames" @change="saveSettings">
                    <span class="toggle-slider"></span>
                  </label>
                </div>

                <div class="setting-item">
                  <div class="setting-info">
                    <div class="setting-name">æ˜¾ç¤ºè£…å¤‡æç¤º</div>
                    <div class="setting-desc">æ‚¬åœè£…å¤‡æ—¶æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯</div>

                  </div>
                  <label class="setting-toggle">
                    <input type="checkbox" v-model="showEquipTooltips" @change="saveSettings">
                    <span class="toggle-slider"></span>
                  </label>
                </div>

                <div class="setting-item">
                  <div class="setting-info">
                    <div class="setting-name">è‡ªåŠ¨ä¿å­˜æ”¶è—</div>
                    <div class="setting-desc">æ”¶è—æ“ä½œåè‡ªåŠ¨ä¿å­˜åˆ°æœ¬åœ°</div>

                  </div>
                  <label class="setting-toggle">
                    <input type="checkbox" v-model="autoSaveFavorites" @change="saveSettings">
                    <span class="toggle-slider"></span>
                  </label>
                </div>
              </div>

              <!-- è®¾ç½®æ“ä½œæŒ‰é’® -->
              <div class="settings-actions">
                <button class="feature-btn secondary" @click="resetSettings" title="æ¢å¤é»˜è®¤è®¾ç½®">
                  <span class="btn-icon">ğŸ”„</span>
                  <span class="btn-text">æ¢å¤é»˜è®¤</span>
                </button>
                <button class="feature-btn secondary" @click="exportSettings" title="å¯¼å‡ºè®¾ç½®é…ç½®">
                  <span class="btn-icon">ğŸ“‹</span>
                  <span class="btn-text">å¯¼å‡ºè®¾ç½®</span>
                </button>
              </div>
            </div>

            <!-- å®ç”¨å·¥å…·å†…å®¹ -->
            <div v-if="activeFeatureTab === 'tools'" class="feature-content-panel">
              <h4 class="content-title">å®ç”¨å·¥å…·</h4>
              <div class="feature-buttons">

                <button class="feature-btn" @click="showComingSoon('é˜µå®¹åˆ†æå™¨')" title="é˜µå®¹åˆ†æåŠŸèƒ½å³å°†æ¨å‡º">
                  <span class="btn-icon">ğŸ“Š</span>
                  <span class="btn-text">é˜µå®¹åˆ†æ</span>
                  <span class="btn-desc">åˆ†æé˜µå®¹å¼ºåº¦å’Œæ­é…</span>
                </button>
                <button class="feature-btn" @click="showComingSoon('è£…å¤‡æ¨èå™¨')" title="è£…å¤‡æ¨èåŠŸèƒ½å³å°†æ¨å‡º">
                  <span class="btn-icon">âš”ï¸</span>
                  <span class="btn-text">è£…å¤‡æ¨è</span>
                  <span class="btn-desc">æ™ºèƒ½æ¨èè£…å¤‡æ­é…</span>
                </button>
              </div>

              <!-- å·¥å…·è¯´æ˜ -->
              <div class="tools-info">
                <div class="info-header">
                  <span class="info-icon">ğŸ’¡</span>
                  <span class="info-title">å·¥å…·è¯´æ˜</span>
                </div>
                <div class="info-content">
                  <div class="info-item">
                    <strong>ç«™ä½å›¾ï¼š</strong>å¯è§†åŒ–çš„æ£‹ç›˜å·¥å…·ï¼Œå¸®åŠ©æ‚¨è§„åˆ’è‹±é›„ç«™ä½ï¼Œç‚¹å‡»æ ¼å­å¯ä»¥æ ‡è®°ä½ç½®ã€‚
                  </div>
                  <div class="info-item">
                    <strong>æ›´å¤šå·¥å…·ï¼š</strong>æˆ‘ä»¬æ­£åœ¨å¼€å‘æ›´å¤šå®ç”¨å·¥å…·ï¼Œæ•¬è¯·æœŸå¾…ï¼
                  </div>
                </div>
              </div>
            </div>

            <!-- å¸®åŠ©ä¿¡æ¯å†…å®¹ -->
            <div v-if="activeFeatureTab === 'help'" class="feature-content-panel">
              <h4 class="content-title">å¸®åŠ©ä¸ä¿¡æ¯</h4>
              <div class="help-sections">
                <div class="help-section">
                  <div class="help-section-title">
                    <span class="help-icon">ğŸ“–</span>
                    <span>ä½¿ç”¨æŒ‡å—</span>
                  </div>
                  <div class="help-buttons">
                    <button class="help-btn" @click="showHelp">
                      <span class="btn-icon">â“</span>
                      <span class="btn-text">ä½¿ç”¨è¯´æ˜</span>
                    </button>
                    <button class="help-btn" @click="showShortcuts">
                      <span class="btn-icon">âŒ¨ï¸</span>
                      <span class="btn-text">å¿«æ·é”®</span>
                    </button>
                  </div>
                </div>

                <div class="help-section">
                  <div class="help-section-title">
                    <span class="help-icon">ğŸ“‹</span>
                    <span>åº”ç”¨ä¿¡æ¯</span>
                  </div>
                  <div class="help-buttons">
                    <button class="help-btn" @click="showAbout">
                      <span class="btn-icon">â„¹ï¸</span>
                      <span class="btn-text">å…³äºåº”ç”¨</span>
                    </button>
                    <button class="help-btn" @click="showVersionInfo">
                      <span class="btn-icon">ğŸ·ï¸</span>
                      <span class="btn-text">ç‰ˆæœ¬ä¿¡æ¯</span>
                    </button>
                  </div>
                </div>
              </div>

              <!-- å¿«é€Ÿæç¤º -->
              <div class="quick-tips">
                <div class="tips-header">
                  <span class="tips-icon">ğŸ’¡</span>
                  <span class="tips-title">å¿«é€Ÿæç¤º</span>
                </div>
                <div class="tips-list">
                  <div class="tip-item">
                    <span class="tip-key">Esc</span>
                    <span class="tip-desc">å…³é—­å½“å‰é¢æ¿</span>
                  </div>
                  <div class="tip-item">
                    <span class="tip-key">Ctrl+F</span>
                    <span class="tip-desc">èšç„¦æœç´¢æ¡†</span>
                  </div>
                  <div class="tip-item">
                    <span class="tip-key">Ctrl+E</span>
                    <span class="tip-desc">å¯¼å‡ºæ”¶è—</span>
                  </div>
                  <div class="tip-item">
                    <span class="tip-key">Ctrl+R</span>
                    <span class="tip-desc">é‡æ–°åŠ è½½æ•°æ®</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- æ·»åŠ ç®€å•æ–‡æœ¬æç¤ºæ¡† -->
    <div class="simple-tooltip" v-show="simpleTooltipVisible" :style="simpleTooltipStyle">
      {{ simpleTooltipText }}
    </div>

    <!-- ä¿®æ”¹è£…å¤‡æç¤ºæ¡†ç»“æ„ï¼Œç§»åŠ¨åˆæˆå…¬å¼ä½ç½® -->
    <div class="equip-tooltip-panel" v-show="equipTooltipVisible" :style="equipTooltipStyle">
      <!-- æ ‡é¢˜åŒºåŸŸ -->
      <div class="equip-tooltip-header">
        <div class="equip-title-row">
          <img :src="currentEquip.imagePath" :alt="currentEquip.name" class="equip-title-image" />
          <div class="equip-tooltip-name">{{ currentEquip.name }}</div>
        </div>
      </div>

      <!-- åˆæˆå…¬å¼åŒºåŸŸ - æ·»åŠ æ— æ³•åˆæˆæç¤º -->
      <div class="equip-recipe">
        <div class="recipe-title">è£…å¤‡ç»„åˆ</div>
        <div v-if="currentEquip.formula" class="recipe-container">
          <template v-for="(formulaId, idx) in currentEquip.formula.split(',')" :key="idx">
            <div class="recipe-item">
              <img :src="getEquipImage(formulaId)" :alt="getEquipName(formulaId)" class="recipe-image" />
            </div>
            <div v-if="idx === 0" class="recipe-plus">+</div>
          </template>
        </div>
        <div v-else class="recipe-empty">è¯¥è£…å¤‡æ— æ³•åˆæˆ</div>
      </div>



      <!-- è£…å¤‡æ•ˆæœæè¿° -->
      <div class="equip-effect-description" v-html="formatEquipDescription(currentEquip.effect)"></div>
    </div>

    <!-- æµ·å…‹æ–¯æ‚¬æµ®æç¤ºæ¡† -->
    <div class="hex-tooltip-panel" v-show="hexTooltipVisible" :style="hexTooltipStyle">
      <!-- æ ‡é¢˜åŒºåŸŸ -->
      <div class="hex-tooltip-header">
        <div class="hex-title-row">
          <img v-if="currentHex && (currentHex.imagePath || currentHex.imgUrl)"
            :src="currentHex.imagePath || currentHex.imgUrl" :alt="currentHex.name" class="hex-title-image" />
          <div class="hex-tooltip-name">{{ currentHex ? currentHex.name : '' }}</div>
        </div>
      </div>

      <!-- åˆ†å‰²çº¿ -->
      <div class="tooltip-divider"></div>

      <!-- æµ·å…‹æ–¯æ•ˆæœæè¿° -->
      <div class="hex-effect" v-if="currentHex && (currentHex.description || currentHex.introduce)">
        {{ currentHex.description || currentHex.introduce }}
      </div>
    </div>

    <!-- ç­›é€‰é¢æ¿ -->
    <div class="filter-panel" :class="showFilterPanel ? 'visible' : 'hidden'">
      <div class="filter-panel-header">
        <h3>ç­›é€‰æ¡ä»¶</h3>
        <button class="filter-close-btn" @click="showFilterPanel = false">Ã—</button>
      </div>

      <!-- èŒä¸šç­›é€‰éƒ¨åˆ† -->
      <div class="filter-section">
        <h4>èŒä¸šç­›é€‰</h4>
        <div class="filter-options">
          <div v-for="job in allJobs" :key="'job-'+job" class="filter-option"
            :class="{ selected: selectedJobs.includes(job) }" @click="toggleJobFilter(job)">
            <span class="filter-checkbox">
              <span v-if="selectedJobs.includes(job)" class="checkbox-inner"></span>
            </span>
            <span class="filter-label">{{ job }}</span>
          </div>

          <div v-if="allJobs.length === 0" class="no-filter-options">
            åŠ è½½ä¸­æˆ–æ— å¯ç”¨é€‰é¡¹
          </div>
        </div>
      </div>

      <!-- ç§æ—/ç¾ç»Šç­›é€‰éƒ¨åˆ† -->
      <div class="filter-section">
        <h4>ç¾ç»Šç­›é€‰</h4>
        <div class="filter-options">
          <div v-for="race in allRaces" :key="'race-'+race" class="filter-option"
            :class="{ selected: selectedRaces.includes(race) }" @click="toggleRaceFilter(race)">
            <span class="filter-checkbox">
              <span v-if="selectedRaces.includes(race)" class="checkbox-inner"></span>
            </span>
            <span class="filter-label">{{ race }}</span>
          </div>

          <div v-if="allRaces.length === 0" class="no-filter-options">
            åŠ è½½ä¸­æˆ–æ— å¯ç”¨é€‰é¡¹
          </div>
        </div>
      </div>

      <!-- ç­‰çº§ç­›é€‰éƒ¨åˆ† -->
      <div class="filter-section">
        <h4>ç­‰çº§ç­›é€‰</h4>
        <div class="filter-options">
          <div v-for="tier in allTiers" :key="'tier-'+tier" class="filter-option"
            :class="{ selected: selectedTiers.includes(tier) }" @click="toggleTierFilter(tier)">
            <span class="filter-checkbox">
              <span v-if="selectedTiers.includes(tier)" class="checkbox-inner"></span>
            </span>
            <span class="filter-label">{{ tier }}</span>
          </div>
        </div>
      </div>

    </div>



    <!-- Windowsé£æ ¼å¯¹è¯æ¡† -->
    <div v-if="showDialog" class="dialog-overlay" @click="closeDialog">
      <div class="windows-dialog" @click.stop>
        <!-- æ ‡é¢˜æ  -->
        <div class="dialog-titlebar">
          <span class="dialog-title">{{ dialogTitle }}</span>
          <button class="dialog-close-btn" @click="closeDialog">Ã—</button>
        </div>

        <!-- å†…å®¹åŒºåŸŸ -->
        <div class="dialog-content">
          <!-- å›¾æ ‡åŒºåŸŸ -->
          <div class="dialog-icon">
            <div v-if="dialogType === 'info'" class="icon-info">â„¹ï¸</div>
            <div v-else-if="dialogType === 'warning'" class="icon-warning">âš ï¸</div>
            <div v-else-if="dialogType === 'error'" class="icon-error">âŒ</div>
            <div v-else-if="dialogType === 'confirm'" class="icon-confirm">â“</div>
            <div v-else-if="dialogType === 'success'" class="icon-success">âœ…</div>
          </div>

          <!-- æ¶ˆæ¯åŒºåŸŸ -->
          <div class="dialog-message">
            <div v-html="dialogMessage"></div>
          </div>
        </div>

        <!-- æŒ‰é’®åŒºåŸŸ -->
        <div class="dialog-buttons">
          <button v-for="button in dialogButtons" :key="button.text" class="dialog-btn"
            :class="button.primary ? 'btn-primary' : 'btn-secondary'" @click="handleDialogButton(button.action)">
            {{ button.text }}
          </button>
        </div>
      </div>
    </div>
    <script>
      function onNative(customMsg, response) {
        switch (customMsg) {
          case 0x001:

            window.yuanchengdata = response;
            

            break;

          case 0x002:
            console.log("è¿™æ˜¯å¦ä¸€ä¸ªè¯·æ±‚çš„å“åº”:", response);
            break;

          default:
            console.log("æœªçŸ¥è¯·æ±‚çš„å“åº”:", response);
        }




      }

    </script>
    <script>
      const App = {
        data() {
          return {
            loading: true, // åŠ è½½çŠ¶æ€
            error: null, // é”™è¯¯ä¿¡æ¯
            searchText: "", // ç”¨æˆ·æœç´¢è¾“å…¥
            hero_avatar_xiao: "",
            hero_pic_da: "",
            hero_pic_da_RGM: "",
            yuanchengdata: null,
            activeTab: "tft", // å½“å‰æ¿€æ´»çš„æ ‡ç­¾é¡µï¼š'opgg'æˆ–'tft' - é»˜è®¤é€‰æ‹©å®˜æ–¹é˜µå®¹
            selectedLineup: null, // å½“å‰é€‰ä¸­çš„é˜µå®¹
            currentBoardLevel: "l9", // å½“å‰æ˜¾ç¤ºçš„é˜µå®¹ç­‰çº§ï¼š'l6'æˆ–'l8'
            l9CoordinateMode: "primary", // L9é˜¶æ®µåæ ‡æ¨¡å¼ï¼š'primary'(x,y) æˆ– 'secondary'(x2,y2)
            Data: {
              current: {
                TFTChampionData: null,
                TFTRaceData: null,
                TFTJobData: null,
                TFTEquipData: null,
                TFTHexData: null,
                TFTGoopData: null,
                TFTLineupList: null,
                OPGLineupList: null,
              },
              rgm: {
                TFTChampionData: null,
                TFTRaceData: null,
                TFTJobData: null,
                TFTEquipData: null,
                TFTHexData: null,
                TFTGoopData: null,
                TFTLineupList: null,
              },
            },
            showingAttributeTooltip: false,
            attributeTooltipStyle: {
              top: "0px",
              left: "0px",
            },
            currentAttributeData: {
              name: "",
              imagePath: "",
              introduce: "",
              level: [],
              race_color_list: "",
              racejobID: "",
              quanbuheros: [],
            },
            showLineupBoard: false, // æ§åˆ¶å¼¹çª—æ˜¾ç¤º
            tooltipVisible: false,
            tooltipHero: null,
            tooltipX: 0,
            tooltipY: 0,
            tooltipDebounceTimer: null, // é˜²æŠ–å®šæ—¶å™¨
            equipTooltipDebounceTimer: null, // è£…å¤‡æç¤ºé˜²æŠ–å®šæ—¶å™¨
            isPositionPanelTooltip: false, // æ ‡è¯†æ˜¯å¦æ¥è‡ªposition-panelçš„æ‚¬æµ®æ˜¾ç¤º
            topMenu: '', // æ–°å¢é¡¶éƒ¨èœå•çŠ¶æ€
            showLineupDetail: false, // æ˜¯å¦æ˜¾ç¤ºé˜µå®¹è¯¦æƒ…
            showEarlyMid: true, // æ–°å¢ï¼šå‰ä¸­æœŸæ˜¾ç¤ºæ§åˆ¶
            showPositionPanel: false, // æ˜¯å¦æ˜¾ç¤ºç«™ä½å›¾çª—å£
            positionBoard: [], // æ£‹ç›˜ç«™ä½æ•°æ® 4x7çš„äºŒç»´æ•°ç»„
            selectedPositions: new Set(), // å·²é€‰æ‹©çš„ä½ç½®é›†åˆ
            replaceableHeroesExpanded: false, // å¯æ›¿æ¢è‹±é›„åŒºåŸŸå±•å¼€çŠ¶æ€
            replaceableHeroesData: [ // å¯æ›¿æ¢è‹±é›„æ•°æ®
              {
                "hero_id": "518", // å¦®è”»
                "replace_heros": "412" // æ›¿æ¢è‹±é›„
              },
              {
                "hero_id": "876", // å¦ä¸€ä¸ªè‹±é›„
                "replace_heros": "53" // æ›¿æ¢è‹±é›„
              }
            ],
            currentLineupPositions: [], // å½“å‰é˜µå®¹çš„ç«™ä½æ•°æ®
            simpleTooltipVisible: false,
            simpleTooltipText: '',
            simpleTooltipStyle: {
              top: '0px',
              left: '0px'
            },
            currentEquip: {
              name: '',
              imagePath: '',
              effect: '',
              formula: ''
            },
            equipTooltipVisible: false,
            equipTooltipStyle: {
              top: '0px',
              left: '0px'
            },
            // æµ·å…‹æ–¯æ‚¬æµ®æç¤ºæ¡†ç›¸å…³
            currentHex: {
              name: '',
              imagePath: '',
              imgUrl: '',
              description: '',
              introduce: ''
            },
            hexTooltipVisible: false,
            hexTooltipStyle: {
              top: '0px',
              left: '0px'
            },
            // æµ·å…‹æ–¯é€‰æ‹©æ‚¬æµ®æç¤ºç›¸å…³
            hexStrategyTooltipVisible: false,
            // å‰æœŸè¿‡åº¦æ‚¬æµ®æç¤ºç›¸å…³
            earlyStrategyTooltipVisible: false,
            // è£…å¤‡æ­é…æ‚¬æµ®æç¤ºç›¸å…³
            equipmentStrategyTooltipVisible: false,
            // ç«™ä½æŠ€å·§æ‚¬æµ®æç¤ºç›¸å…³
            positionStrategyTooltipVisible: false,
            selectedHeroes: [], // æ”¹ä¸ºæ•°ç»„ä»¥æ”¯æŒå¤šé€‰
            showFilterPanel: false, // ä¿ç•™ï¼šæ˜¯å¦æ˜¾ç¤ºç­›é€‰é¢æ¿
            filterPanelX: 0,
            filterPanelY: 0,
            loadingProgress: 0, // åŠ è½½è¿›åº¦ï¼Œ0-100
            loadingMessage: "æ­£åœ¨åŠ è½½æ•°æ®", // åŠ è½½çŠ¶æ€æ¶ˆæ¯
            selectedJobs: [], // é€‰ä¸­çš„èŒä¸š
            selectedRaces: [], // é€‰ä¸­çš„ç§æ—/ç¾ç»Š
            selectedTiers: [], // é€‰ä¸­çš„ç­‰çº§
            allJobs: [], // æ‰€æœ‰å¯ç”¨èŒä¸š
            allRaces: [], // æ‰€æœ‰å¯ç”¨ç§æ—/ç¾ç»Š
            allTiers: ['OP', 'S', 'A', 'B', 'C', 'D'], // æ‰€æœ‰å¯ç”¨ç­‰çº§
            favoriteLineups: [], // æ”¶è—çš„é˜µå®¹åˆ—è¡¨
            showDialog: false, // æ–°å¢ï¼šæ˜¯å¦æ˜¾ç¤ºå¯¹è¯æ¡†
            dialogTitle: '', // å¯¹è¯æ¡†æ ‡é¢˜
            dialogType: '', // å¯¹è¯æ¡†ç±»å‹ï¼šinfo, warning, error, confirm, success
            dialogMessage: '', // å¯¹è¯æ¡†æ¶ˆæ¯
            dialogButtons: [], // å¯¹è¯æ¡†æŒ‰é’®é…ç½®
            dialogCallback: null, // å¯¹è¯æ¡†å›è°ƒå‡½æ•°
            showAllFavorites: false, // æ˜¯å¦æ˜¾ç¤ºå…¨éƒ¨æ”¶è—é˜µå®¹ï¼ˆå¿½ç•¥èµ›å­£è¿‡æ»¤ï¼‰
            showSeasonSelector: false, // æ˜¯å¦æ˜¾ç¤ºèµ›å­£é€‰æ‹©å™¨
            availableSeasons: [], // å¯ç”¨çš„èµ›å­£åˆ—è¡¨
            selectedSeason: 'current', // å½“å‰é€‰æ‹©çš„èµ›å­£
            showHeroNames: true, // æ˜¯å¦æ˜¾ç¤ºè‹±é›„åç§°
            showEquipTooltips: true, // æ˜¯å¦æ˜¾ç¤ºè£…å¤‡æç¤º
            autoSaveFavorites: true, // æ˜¯å¦è‡ªåŠ¨ä¿å­˜æ”¶è—
            activeFeatureTab: 'favorites', // å½“å‰æ¿€æ´»çš„åŠŸèƒ½æ ‡ç­¾é¡µ
            strategyExpanded: false, // æ”»ç•¥ä¿¡æ¯åŒºåŸŸå±•å¼€çŠ¶æ€ï¼Œé»˜è®¤æ”¶èµ·
            chosenHeroExpanded: false, // æ¨èå¤©é€‰è‹±é›„åŒºåŸŸå±•å¼€çŠ¶æ€ï¼Œé»˜è®¤æ”¶èµ·
          };
        },
        computed: {
          // æ£€æŸ¥å½“å‰L9é˜µå®¹æ˜¯å¦æœ‰å¤‡ç”¨åæ ‡æ•°æ®
          hasL9SecondaryCoordinates() {
            if (!this.selectedLineup || this.currentBoardLevel !== 'l9') {
              return false;
            }
            const heroList = this.selectedLineup.hero_location_l9 || [];
            // æ£€æŸ¥æ˜¯å¦æœ‰è‹±é›„å…·æœ‰éé›¶çš„x2å’Œy2åæ ‡
            return heroList.some(hero =>
              hero.hasOwnProperty('x2') &&
              hero.hasOwnProperty('y2') &&
              hero.x2 !== 0 &&
              hero.y2 !== 0
            );
          },
          // è¿‡æ»¤æœ‰æ•ˆçš„è‹±é›„æ•°æ®
          uniqueRaces() {
            if (!this.Data.current.TFTRaceData) return [];
            return this.Data.current.TFTRaceData.map((race) => ({
              id: race.raceId,
              name: race.name,
            }));
          },
          // è·å–æ‰€æœ‰å”¯ä¸€èŒä¸š
          uniqueJobs() {
            if (!this.Data.current.TFTJobData) return [];
            return this.Data.current.TFTJobData.map((job) => ({
              id: job.jobId,
              name: job.name,
            }));
          },
          // æ ¹æ®å½“å‰é€‰ä¸­çš„æ ‡ç­¾é¡µè¿”å›å¯¹åº”çš„é˜µå®¹æ•°æ®
          currentLineupList() {
            if (this.activeTab === "opgg") {
              // å¯¹OPGGé˜µå®¹æ•°æ®è¿›è¡Œè§£å‹ç¼©ï¼Œç¡®ä¿chessDataæ­£ç¡®æ˜¾ç¤º
              const opggLineups = this.Data.current.OPGLineupList || [];
              return opggLineups.map(lineup => this.decompressLineupData(lineup));
            } else if (this.activeTab === "tft") {
              // å¯¹TFTé˜µå®¹æ•°æ®è¿›è¡Œè§£å‹ç¼©ï¼Œç¡®ä¿chessDataæ­£ç¡®æ˜¾ç¤º
              const tftLineups = this.Data.current.TFTLineupList || [];
              return tftLineups.map(lineup => this.decompressLineupData(lineup));
            } else if (this.activeTab === "favorite") {
              // å¯¹æ”¶è—çš„é˜µå®¹è¿›è¡Œè§£å‹ç¼©ï¼Œæ¢å¤å®Œæ•´æ•°æ®ç”¨äºæ˜¾ç¤º
              const decompressedFavorites = (this.favoriteLineups || []).map(lineup => this.decompressLineupData(lineup));

              // æ ¹æ®showAllFavoritesçŠ¶æ€å†³å®šæ˜¯å¦è¿‡æ»¤èµ›å­£
              if (this.showAllFavorites) {
                return decompressedFavorites; // æ˜¾ç¤ºå…¨éƒ¨æ”¶è—é˜µå®¹
              } else {
                return this.filterFavoritesBySeason(decompressedFavorites); // åªæ˜¾ç¤ºå½“å‰èµ›å­£
              }
            }
            return [];
          },
          heroDataList() {
            if (!this.Data.current.TFTChampionData) return [];
            return this.Data.current.TFTChampionData.filter((hero) => {
              // åŸºç¡€è¿‡æ»¤æ¡ä»¶
              const validHero =
                hero.price && hero.price !== "0" && parseInt(hero.price) > 0;

              if (hero.jobs != "å¬å”¤ç‰©") {
                ////console.log(hero.title);
                ////console.log(hero.skillName);
                ////console.log(hero.skillDetail)
              }


              return (
                validHero

              );
            })
              .map((hero) => ({
                ...hero,
                selectednapai: hero.selectednapai || false, // æ·»åŠ selectedå±æ€§ï¼Œé»˜è®¤ä¸ºfalse
              }))
              .sort((a, b) => parseInt(a.price) - parseInt(b.price));
          },
          filteredLineups() {
            if (!this.currentLineupList) {
              return [];
            }

            let filtered = this.currentLineupList;

            // åº”ç”¨æœç´¢æ–‡æœ¬ç­›é€‰
            if (this.searchText && this.searchText.trim() !== '') {
              const searchTerm = this.searchText.toLowerCase().trim();

              filtered = filtered.filter(lineup => {
                // æœç´¢é˜µå®¹åç§°
                if (lineup.name && lineup.name.toLowerCase().includes(searchTerm)) {
                  return true;
                }

                // æœç´¢è‹±é›„å…³é”®è¯ï¼ˆä¸­æ–‡åã€è‹±æ–‡åã€åˆ«åã€æ‹¼éŸ³ç­‰ï¼‰
                if (lineup.hero_keywords_l9 && lineup.hero_keywords_l9.toLowerCase().includes(searchTerm)) {
                  return true;
                }

                // æœç´¢è‹±é›„èŒä¸š
                if (lineup.hero_jobs_l9 && lineup.hero_jobs_l9.toLowerCase().includes(searchTerm)) {
                  return true;
                }

                // æœç´¢è‹±é›„ç§æ—/ç¾ç»Š
                if (lineup.hero_races_l9 && lineup.hero_races_l9.toLowerCase().includes(searchTerm)) {
                  return true;
                }

                return false;
              });
            }

            // åº”ç”¨èŒä¸šç­›é€‰
            if (this.selectedJobs.length > 0) {
              filtered = filtered.filter(lineup => {
                if (!lineup.hero_jobs_l9) return false;

                // æ£€æŸ¥æ˜¯å¦åŒ…å«æ‰€æœ‰é€‰ä¸­çš„èŒä¸š
                return this.selectedJobs.every(job =>
                  lineup.hero_jobs_l9.includes(job)
                );
              });
            }

            // åº”ç”¨ç§æ—/ç¾ç»Šç­›é€‰
            if (this.selectedRaces.length > 0) {
              filtered = filtered.filter(lineup => {
                if (!lineup.hero_races_l9) return false;

                // æ£€æŸ¥æ˜¯å¦åŒ…å«æ‰€æœ‰é€‰ä¸­çš„ç§æ—/ç¾ç»Š
                return this.selectedRaces.every(race =>
                  lineup.hero_races_l9.includes(race)
                );
              });
            }

            // åº”ç”¨ç­‰çº§ç­›é€‰
            if (this.selectedTiers.length > 0) {
              filtered = filtered.filter(lineup => {
                if (!lineup.quality) return false;

                // æ£€æŸ¥é˜µå®¹ç­‰çº§æ˜¯å¦åœ¨é€‰ä¸­çš„ç­‰çº§ä¸­
                return this.selectedTiers.includes(lineup.quality);
              });
            }

            return filtered;
          },
          uniqueJobsAndRaces() {
            const jobs = [];
            const races = [];

            // ä»TFTJobDataè·å–èŒä¸šä¿¡æ¯
            if (this.Data.current && this.Data.current.TFTJobData) {
              this.Data.current.TFTJobData.forEach(job => {
                if (job.name) jobs.push(job.name);
              });
            }

            // ä»TFTRaceDataè·å–ç¾ç»Šä¿¡æ¯
            if (this.Data.current && this.Data.current.TFTRaceData) {
              this.Data.current.TFTRaceData.forEach(race => {
                if (race.name) races.push(race.name);
              });
            }

            return {
              jobs: jobs.sort(),
              races: races.sort()
            };
          },
          // åˆ¤æ–­å½“å‰æ˜¯å¦ä¸ºè½®æ¢æ¨¡å¼
          isRgmSeason() {
            return this.selectedSeason === 'rgm';
          }
        },
        methods: {
          // åˆ‡æ¢æ”»ç•¥ä¿¡æ¯å±•å¼€/æ”¶èµ·çŠ¶æ€
          toggleStrategyExpanded() {
            this.strategyExpanded = !this.strategyExpanded;
          },

          // åˆ‡æ¢æ¨èå¤©é€‰è‹±é›„å±•å¼€/æ”¶èµ·çŠ¶æ€
          toggleChosenHeroExpanded() {
            this.chosenHeroExpanded = !this.chosenHeroExpanded;
          },

          // æ£€æŸ¥å½“å‰é˜µå®¹æ˜¯å¦æœ‰æ¨èå¤©é€‰è‹±é›„ä¿¡æ¯
          hasChosenHeroInfo() {
            if (!this.selectedLineup) return false;

            // è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥æ•°æ®æ˜¯å¦æœ‰æ•ˆï¼ˆä¸ä¸ºç©ºå­—ç¬¦ä¸²ä¸”æœ‰å†…å®¹ï¼‰
            const hasValidData = (data) => {
              if (!data) return false;
              if (typeof data === 'string') return data.trim() !== '';
              if (Array.isArray(data)) return data.length > 0;
              return false;
            };

            // æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•é˜¶æ®µçš„æ¨èå¤©é€‰è‹±é›„æ•°æ®
            return (
              hasValidData(this.selectedLineup.recomm_chosen_heros_early) ||
              hasValidData(this.selectedLineup.recomm_chosen_heros_middle) ||
              hasValidData(this.selectedLineup.recomm_chosen_heros) ||
              hasValidData(this.selectedLineup.replace_chosen_heros)
            );
          },

          // è·å–æŒ‡å®šé˜¶æ®µçš„æ¨èå¤©é€‰è‹±é›„æ•°æ®
          getChosenHeroData(stage) {
            if (!this.selectedLineup) return [];

            let heroIds = [];
            let synergyIds = [];

            switch (stage) {
              case 'early':
                heroIds = this.selectedLineup.recomm_chosen_heros_early || [];
                synergyIds = this.selectedLineup.recomm_chosen_heros_synergy_early || [];
                break;
              case 'middle':
                heroIds = this.selectedLineup.recomm_chosen_heros_middle || [];
                synergyIds = this.selectedLineup.recomm_chosen_heros_synergy_middle || [];
                break;
              case 'late':
                heroIds = this.selectedLineup.recomm_chosen_heros || [];
                synergyIds = this.selectedLineup.recomm_chosen_heros_synergy || [];
                break;
              case 'replace':
                heroIds = this.selectedLineup.replace_chosen_heros || [];
                synergyIds = this.selectedLineup.replace_chosen_heros_synergy || [];
                break;
              default:
                return [];
            }

            // å¤„ç†æ•°æ®ç±»å‹è½¬æ¢ï¼šå­—ç¬¦ä¸²è½¬æ•°ç»„ï¼Œç¡®ä¿æ•°æ®æ ¼å¼æ­£ç¡®
            const processData = (data) => {
              if (!data) return [];
              if (typeof data === 'string') {
                // å¦‚æœæ˜¯å­—ç¬¦ä¸²ä¸”ä¸ä¸ºç©ºï¼Œè½¬æ¢ä¸ºåŒ…å«å•ä¸ªå…ƒç´ çš„æ•°ç»„
                return data.trim() !== '' ? [data.trim()] : [];
              }
              if (Array.isArray(data)) return data;
              return [];
            };

            // å¤„ç†ç¾ç»Šæ•°æ®ï¼šæ ¹æ®ç¾ç»Šç±»å‹æå–å¯¹åº”çš„ID
            const processSynergyData = (data) => {
              if (!data) return [];
              if (typeof data === 'string') {
                return data.trim() !== '' ? [data.trim()] : [];
              }
              if (Array.isArray(data)) return data;
              // å¤„ç†ç¾ç»Šå¯¹è±¡æ ¼å¼ {race: 'id'} æˆ– {job: 'id'}
              if (typeof data === 'object' && data !== null) {
                const result = [];
                // å¦‚æœæ˜¯raceç±»å‹ï¼Œä»TFTRaceDataä¸­æŸ¥æ‰¾
                if (data.race) {
                  result.push({ type: 'race', id: data.race });
                }
                // å¦‚æœæ˜¯jobç±»å‹ï¼Œä»TFTJobDataä¸­æŸ¥æ‰¾
                if (data.job) {
                  result.push({ type: 'job', id: data.job });
                }
                return result;
              }
              return [];
            };

            heroIds = processData(heroIds);
            synergyIds = processSynergyData(synergyIds);

            // å°†è‹±é›„IDå’Œç¾ç»ŠIDç»„åˆæˆå®Œæ•´çš„æ•°æ®
            const result = [];

            // å¤„ç†è‹±é›„æ•°æ®
            heroIds.forEach((heroId, index) => {
              const heroData = this.getHeroById(heroId);
              if (heroData) {
                let synergy = null;
                // å¤„ç†ç¾ç»Šæ•°æ®
                if (synergyIds[index]) {
                  const synergyData = synergyIds[index];
                  if (typeof synergyData === 'object' && synergyData.type && synergyData.id) {
                    // æ ¹æ®ç¾ç»Šç±»å‹åœ¨å¯¹åº”çš„æ•°æ®æºä¸­æŸ¥æ‰¾
                    if (synergyData.type === 'race' && this.Data.current.TFTRaceData) {
                      const race = this.Data.current.TFTRaceData.find(r => r.raceId === synergyData.id);
                      if (race) synergy = { ...race, type: 'race' };
                    } else if (synergyData.type === 'job' && this.Data.current.TFTJobData) {
                      const job = this.Data.current.TFTJobData.find(j => j.jobId === synergyData.id);
                      if (job) synergy = { ...job, type: 'job' };
                    }
                  } else {
                    // å…¼å®¹æ—§çš„å­—ç¬¦ä¸²æ ¼å¼
                    synergy = this.getSynergyById(synergyData);
                  }
                }

                result.push({
                  type: 'hero',
                  id: heroId,
                  name: heroData.displayName || heroData.name,
                  imagePath: heroData.name || heroData.id + '.png',
                  synergy: synergy
                });
              }
            });


            return result;
          },

          // æ ¹æ®è‹±é›„IDè·å–è‹±é›„æ•°æ®
          getHeroById(heroId) {
            // å‚æ•°éªŒè¯ï¼šç¡®ä¿heroIdå­˜åœ¨ä¸”ä¸ä¸ºç©º
            if (!heroId || heroId === '' || heroId === null || heroId === undefined) {
              return null;
            }

            if (!this.Data.current.TFTChampionData) return null;

            // å®‰å…¨åœ°è½¬æ¢ä¸ºå­—ç¬¦ä¸²è¿›è¡Œæ¯”è¾ƒ
            const heroIdStr = String(heroId).trim();
            if (heroIdStr === '') return null;

            return this.Data.current.TFTChampionData.find(hero => hero.chessId === heroIdStr);
          },

          // æ ¹æ®ç¾ç»ŠIDè·å–ç¾ç»Šæ•°æ®
          getSynergyById(synergyId) {
            // å‚æ•°éªŒè¯ï¼šç¡®ä¿synergyIdå­˜åœ¨ä¸”ä¸ä¸ºç©º
            if (!synergyId || synergyId === '' || synergyId === null || synergyId === undefined) {
              return null;
            }

            // å®‰å…¨åœ°è½¬æ¢ä¸ºå­—ç¬¦ä¸²è¿›è¡Œæ¯”è¾ƒ
            const synergyIdStr = String(synergyId).trim();
            if (synergyIdStr === '') return null;

            // å…ˆåœ¨ç§æ—æ•°æ®ä¸­æŸ¥æ‰¾
            if (this.Data.current.TFTRaceData) {
              const race = this.Data.current.TFTRaceData.find(race => race.raceId === synergyIdStr);
              if (race) return { ...race, type: 'race' };
            }

            // å†åœ¨èŒä¸šæ•°æ®ä¸­æŸ¥æ‰¾
            if (this.Data.current.TFTJobData) {
              const job = this.Data.current.TFTJobData.find(job => job.jobId === synergyIdStr);
              if (job) return { ...job, type: 'job' };
            }

            return null;
          },

          // è·å–è‹±é›„å¤´åƒå›¾ç‰‡è·¯å¾„
          getHeroImage(heroId) {
            // å‚æ•°éªŒè¯ï¼šç¡®ä¿heroIdå­˜åœ¨ä¸”ä¸ä¸ºç©º
            if (!heroId || heroId === '' || heroId === null || heroId === undefined) {
              return this.hero_avatar_xiao.replace('{{name}}', 'default.png');
            }

            const heroData = this.getHeroById(heroId);
            if (heroData && heroData.imagePath) {
              return heroData.imagePath;
            }
            // å¦‚æœæ²¡æœ‰imagePathï¼Œä½¿ç”¨é»˜è®¤çš„å¤´åƒè·¯å¾„æ¨¡æ¿
            // ä½¿ç”¨è‹±é›„çš„nameå±æ€§æˆ–chessIdä½œä¸ºæ–‡ä»¶å
            let imageName = 'default.png';
            if (heroData && heroData.name) {
              imageName = heroData.name + '.png';
            } else {
              const safeHeroId = String(heroId).trim();
              imageName = safeHeroId + '.png';
            }
            return this.hero_avatar_xiao.replace('{{name}}', imageName);
          },

          // è·å–è‹±é›„çš„ç¾ç»Šä¿¡æ¯
          getHeroSynergies(heroId) {
            const heroData = this.getHeroById(heroId);
            if (!heroData) return [];

            const synergies = [];

            // è·å–ç§æ—ç¾ç»Š
            if (heroData.raceIds) {
              const raceIds = heroData.raceIds.split(',');
              raceIds.forEach(raceId => {
                const race = this.Data.current.TFTRaceData && this.Data.current.TFTRaceData.find(r => r.raceId === raceId.trim());
                if (race) {
                  synergies.push({ ...race, type: 'race' });
                }
              });
            }

            // è·å–èŒä¸šç¾ç»Š
            if (heroData.jobIds) {
              const jobIds = heroData.jobIds.split(',');
              jobIds.forEach(jobId => {
                const job = this.Data.current.TFTJobData && this.Data.current.TFTJobData.find(j => j.jobId === jobId.trim());
                if (job) {
                  synergies.push({ ...job, type: 'job' });
                }
              });
            }

            return synergies;
          },

          getEquipImage(equipId) {
            if (!this.Data.current.TFTEquipData) return "";
            const equip = this.Data.current.TFTEquipData.find(
              (e) => e.equipId === equipId
            );
            return equip ? equip.imagePath : "";
          },

          // æ ¹æ®è£…å¤‡IDè·å–è£…å¤‡å¯¹è±¡
          getEquipmentById(equipId) {
            if (!this.Data.current.TFTEquipData) return null;
            return this.Data.current.TFTEquipData.find(
              (e) => e.equipId === equipId
            );
          },

          // æ ¹æ®æµ·å…‹æ–¯IDè·å–æµ·å…‹æ–¯å¯¹è±¡
          getHexById(hexId) {
            if (!this.Data.current.TFTHexData) return null;

            // å¦‚æœæ˜¯æ•°ç»„æ ¼å¼
            if (Array.isArray(this.Data.current.TFTHexData)) {
              return this.Data.current.TFTHexData.find(
                (h) => h.hexId === hexId
              );
            }

            // å¦‚æœæ˜¯å¯¹è±¡æ ¼å¼ï¼Œéå†å¯¹è±¡çš„å€¼
            if (typeof this.Data.current.TFTHexData === 'object') {
              for (const key in this.Data.current.TFTHexData) {
                const hex = this.Data.current.TFTHexData[key];
                if (hex && hex.hexId === hexId) {
                  return hex;
                }
              }
            }

            return null;
          },
          getHeroAvatar(hero) {
            if (hero.chessData && hero.chessData.chessId) {
              return this.hero_avatar_xiao.replace(
                "{{chessId}}",
                hero.chessData.chessId
              );
            }
            return "";
          },
          getRelatedHeroes() {
            if (
              !this.Data.current.TFTChampionData ||
              !this.currentAttributeData.racejobID
            ) {
              return [];
            }

            return this.Data.current.TFTChampionData.filter((hero) => {
              // æ£€æŸ¥è‹±é›„æ˜¯å¦åŒ…å«å½“å‰ç¾ç»Šæˆ–èŒä¸š
              const hasRace =
                hero.raceIds &&
                hero.raceIds
                  .split(",")
                  .includes(this.currentAttributeData.racejobID);
              const hasJob =
                hero.jobIds &&
                hero.jobIds
                  .split(",")
                  .includes(this.currentAttributeData.racejobID);
              return (hasRace || hasJob) && hero.price && hero.price !== "0";
            }).slice(0, 8); // é™åˆ¶æ˜¾ç¤ºæ•°é‡
          },
          getBonusCountClass(key) {
            if (!this.currentAttributeData.race_color_list) return "";

            const colorMap = {};
            this.currentAttributeData.race_color_list
              .split(",")
              .forEach((item) => {
                const [k, v] = item.split(":");
                colorMap[k] = v;
              });

            return colorMap[key] ? `level-${colorMap[key]}` : "";
          },
          // æ˜¾ç¤ºå±æ€§æç¤ºæ¡†
          showAttributeTooltip(event, data, type) {
            // ç¡®ä¿æ•°æ®æœ‰æ•ˆ
            if (!data) {
              console.warn("å±æ€§æ•°æ®æ— æ•ˆ");
              return;
            }

            // è®¾ç½®æç¤ºæ¡†æ•°æ®
            this.currentAttributeData = {
              name: data.name || "",
              imagePath: data.imagePath || "",
              introduce: data.introduce || "",
              level: data.level || [],
              race_color_list: data.race_color_list || data.job_color_list,
              racejobID: data.raceId || data.jobId,
              quanbuheros: data.quanbuheros || [],
            };

            // è®¡ç®—æç¤ºæ¡†ä½ç½® - ä¸è‹±é›„æç¤ºæ¡†å¹¶æ’
            const heroTooltip = document.querySelector(".hero-tooltip");
            if (heroTooltip) {
              const heroTooltipRect = heroTooltip.getBoundingClientRect();
              // è®¾ç½®åœ¨è‹±é›„æç¤ºæ¡†å³ä¾§
              this.attributeTooltipStyle = {
                top: heroTooltipRect.top + "px",
                left: heroTooltipRect.right + "px", // å³ä¾§é—´éš”20px
                zIndex: 2000, // ç¡®ä¿åœ¨å…¶ä»–å…ƒç´ ä¹‹ä¸Š
              };
            }

            this.showingAttributeTooltip = true;
          },

          // éšè—å±æ€§æç¤ºæ¡†
          hideAttributeTooltip() {
            this.showingAttributeTooltip = false;
          },
          toggleHeroSelection(hero) {

            // å¤ç”¨selectHeroæ–¹æ³•çš„é€»è¾‘ï¼Œä¿æŒä¸€è‡´æ€§
            this.selectHero(hero);

            // åŒæ—¶ä¿æŒåŸæœ‰é€»è¾‘ï¼Œæ›´æ–°TFTChampionDataä¸­çš„çŠ¶æ€ï¼ˆå¦‚æœéœ€è¦å‘åå…¼å®¹ï¼‰
            const index = this.Data.current.TFTChampionData.findIndex(
              (h) => h.chessId === hero.chessId
            );

            if (index !== -1) {
              // æ ¹æ®selectedHeroesä¸­æ˜¯å¦å­˜åœ¨è¯¥è‹±é›„æ¥è®¾ç½®selectednapai
              const isSelected = this.isHeroSelected(hero.chessId);
              const updatedHero = {
                ...hero,
                selectednapai: isSelected, // ä¸selectedHeroesä¿æŒä¸€è‡´
              };
              this.Data.current.TFTChampionData.splice(index, 1, updatedHero);
            }
          },
          resetSearch() {
            this.searchText = '';
            this.selectedJobs = [];
            this.selectedRaces = [];
            this.selectedTiers = [];
            this.showFilterPanel = false; // é¡ºä¾¿å…³é—­ç­›é€‰é¢æ¿
          },
          // é€‰æ‹©é˜µå®¹å¹¶æ˜¾ç¤ºå…­è¾¹å½¢å¸ƒå±€
          selectLineup(lineup) {
            // æ£€æŸ¥é˜µå®¹æ˜¯å¦åŒ…å«å·²åˆ é™¤çš„è‹±é›„
            if (lineup.hasInvalidHeroes) {
              this.showWarningDialog(
                'æ— æ³•ä½¿ç”¨é˜µå®¹',
                `é˜µå®¹"${lineup.name}"åŒ…å«å·²åˆ é™¤çš„è‹±é›„ï¼Œæ— æ³•ä½¿ç”¨ã€‚<br><br>å»ºè®®åœ¨æ”¶è—ç®¡ç†ä¸­æ¸…ç†è¿‡æ—¶çš„æ”¶è—é˜µå®¹ã€‚`
              );
              return; // é˜»æ­¢ç»§ç»­æ‰§è¡Œ
            }

            //console.log('é€‰æ‹©é˜µå®¹:', lineup);
            //console.log('TFTChampionDataæ˜¯å¦å­˜åœ¨:', !!this.Data.current.TFTChampionData);
            //console.log('TFTChampionDataé•¿åº¦:', this.Data.current.TFTChampionData ? this.Data.current.TFTChampionData.length : 0);

            // å¦‚æœæ˜¯æ”¶è—çš„é˜µå®¹ä¸”æ˜¯å‹ç¼©æ ¼å¼ï¼Œå…ˆè§£å‹ç¼©
            let processedLineup = lineup;
            if (this.activeTab === 'favorite') {
              // æ”¶è—æ ‡ç­¾é¡µçš„æ•°æ®å·²ç»åœ¨currentLineupListä¸­è§£å‹ç¼©äº†ï¼Œç›´æ¥ä½¿ç”¨
              processedLineup = lineup;
            }


            //console.log('L6è‹±é›„æ•°æ®:', processedLineup.hero_location_l6);
            if (processedLineup.hero_location_l6 && processedLineup.hero_location_l6.length > 0) {
              //console.log('ç¬¬ä¸€ä¸ªL6è‹±é›„:', processedLineup.hero_location_l6[0]);
              //console.log('ç¬¬ä¸€ä¸ªL6è‹±é›„çš„æ‰€æœ‰å­—æ®µ:', Object.keys(processedLineup.hero_location_l6[0]));
            }

            // è¾“å‡ºL9é˜¶æ®µæ‰€æœ‰è‹±é›„çš„è¯¦ç»†ä¿¡æ¯
            if (processedLineup.hero_location_l9 && processedLineup.hero_location_l9.length > 0) {
              //console.log('=== L9é˜¶æ®µæ‰€æœ‰è‹±é›„ä¿¡æ¯ ===');
              processedLineup.hero_location_l9.forEach((hero, index) => {
                //console.log(`L9è‹±é›„${index + 1}:`, hero);
                //console.log(`L9è‹±é›„${index + 1}å­—æ®µ:`, Object.keys(hero));
                if (hero.equipData) {
                  //console.log(`L9è‹±é›„${index + 1}è£…å¤‡:`, hero.equipData);
                } else {
                  //console.log(`L9è‹±é›„${index + 1}æ— è£…å¤‡æ•°æ®`);
                }
              });

              // è¾“å‡ºåŸå§‹é˜µå®¹æ•°æ®ä¸­çš„è£…å¤‡ä¿¡æ¯
              //console.log('=== åŸå§‹é˜µå®¹æ•°æ®ä¸­çš„è£…å¤‡ä¿¡æ¯ ===');
              const originalLineup = this.currentLineupList.find(l => l.id === lineup.id);
              if (originalLineup && originalLineup.hero_location_l9) {
                originalLineup.hero_location_l9.forEach((hero, index) => {
                  //console.log(`åŸå§‹L9è‹±é›„${index + 1}:`, hero);
                  //console.log(`åŸå§‹L9è‹±é›„${index + 1}å­—æ®µ:`, Object.keys(hero));
                  if (hero.equipIds) {
                    //console.log(`åŸå§‹L9è‹±é›„${index + 1}è£…å¤‡IDs:`, hero.equipIds);
                  } else {
                    //console.log(`åŸå§‹L9è‹±é›„${index + 1}æ— equipIdså­—æ®µ`);
                  }
                });
              }
            }

            // å…ˆæ¸…ç©ºæ‰€æœ‰é€‰ä¸­çš„è‹±é›„
            this.selectedHeroes = [];

            // é€‰ä¸­é˜µå®¹ä¸­çš„æ‰€æœ‰è‹±é›„
            const lineupHeroes = [];

            // æ”¶é›†æ‰€æœ‰é˜¶æ®µçš„è‹±é›„
            if (processedLineup.hero_location_l6) {
              processedLineup.hero_location_l6.forEach(hero => {
                if (hero.chessData && !lineupHeroes.find(h => h.chessId === hero.chessData.chessId)) {
                  lineupHeroes.push(hero.chessData);
                }
              });
            }

            if (processedLineup.hero_location_l8) {
              processedLineup.hero_location_l8.forEach(hero => {
                if (hero.chessData && !lineupHeroes.find(h => h.chessId === hero.chessData.chessId)) {
                  lineupHeroes.push(hero.chessData);
                }
              });
            }

            if (processedLineup.hero_location_l9) {
              processedLineup.hero_location_l9.forEach(hero => {
                if (hero.chessData && !lineupHeroes.find(h => h.chessId === hero.chessData.chessId)) {
                  lineupHeroes.push(hero.chessData);
                }
              });
            }

            // å°†é˜µå®¹ä¸­çš„è‹±é›„æ·»åŠ åˆ°é€‰ä¸­åˆ—è¡¨
            this.selectedHeroes = [...lineupHeroes];

            this.selectedLineup = processedLineup;
            this.currentBoardLevel = "l9";
            this.l9CoordinateMode = "primary"; // æ¯æ¬¡é€‰æ‹©é˜µå®¹æ—¶é‡ç½®ä¸ºä¸»åæ ‡æ¨¡å¼
            this.showLineupDetail = true;
            this.topMenu = '';
            this.showFilterPanel = false; // é€‰æ‹©é˜µå®¹åå…³é—­ç­›é€‰é¢æ¿

            // è‡ªåŠ¨æ‰“å¼€ç«™ä½å›¾
            this.openPositionPanelWithLineup();
          },

          // å…³é—­é˜µå®¹è¯¦æƒ…
          closeLineupDetail() {
            this.showLineupDetail = false;
            this.selectedLineup = null;
            this.selectedHeroes = []; // æ¸…ç©ºæ‰€æœ‰é€‰ä¸­çš„è‹±é›„
            // åŒæ—¶å…³é—­ç«™ä½å›¾
            this.showPositionPanel = false;
          },

          // æ‰“å¼€ç«™ä½å›¾çª—å£ - æ”¯æŒä¼ å…¥é˜µå®¹æ•°æ®
          openPositionPanel(lineupData = null) {
            this.showPositionPanel = true;
            this.initializePositionBoard(lineupData);
          },

          // ä»é˜µå®¹è¯¦æƒ…çª—å£æ‰“å¼€ç«™ä½å›¾
          openPositionPanelWithLineup() {
            if (!this.selectedLineup) return;


            this.openPositionPanel(this.selectedLineup);
          },

          // å…³é—­ç«™ä½å›¾çª—å£
          closePositionPanel() {
            this.showPositionPanel = false;
            this.currentLineupPositions = [];
          },

          // åˆ‡æ¢ç«™ä½å›¾é˜¶æ®µ
          switchPositionStage(stage) {
            this.currentBoardLevel = stage;
            // é‡æ–°åŠ è½½å½“å‰é˜¶æ®µçš„è‹±é›„ä½ç½®æ•°æ®
            this.openPositionPanelWithLineup();
          },

          // æ£€æŸ¥æŒ‡å®šé˜¶æ®µæ˜¯å¦æœ‰æ•°æ®
          hasStageData(stage) {
            if (!this.selectedLineup) return false;
            const stageData = this.selectedLineup[`hero_location_${stage}`];
            return stageData && Array.isArray(stageData) && stageData.length > 0;
          },

          // è·å–é˜¶æ®µåç§°
          getStageName(stage) {
            const stageNames = {
              'l6': 'æ—©æœŸ',
              'l8': 'ä¸­æœŸ',
              'l9': 'æœ€ç»ˆ'
            };
            return stageNames[stage] || stage;
          },

          // æ£€æŸ¥å½“å‰é˜¶æ®µæ˜¯å¦æœ‰æœ‰æ•ˆçš„ç«™ä½åæ ‡
          hasValidPositions() {
            const heroList = this.getCurrentBoardHeroList();
            if (!heroList || heroList.length === 0) return false;

            // æ£€æŸ¥æ˜¯å¦æœ‰è‹±é›„å…·æœ‰æœ‰æ•ˆçš„åæ ‡ï¼ˆx > 0 && y > 0ï¼‰
            return heroList.some(hero => {
              return hero.x > 0 && hero.y > 0;
            });
          },

          // åˆ‡æ¢L9é˜¶æ®µçš„åæ ‡æ¨¡å¼
          switchL9CoordinateMode(mode) {
            this.l9CoordinateMode = mode;
            // é‡æ–°åŠ è½½å½“å‰é˜¶æ®µçš„è‹±é›„ä½ç½®æ•°æ®
            this.openPositionPanelWithLineup();
          },

          // è·å–å½“å‰é˜¶æ®µçš„è‹±é›„ä½ç½®æ•°æ®ç”¨äºç«™ä½å›¾æ˜¾ç¤º
          getCurrentPositionHeroes() {
            if (!this.selectedLineup) return [];

            const heroList = this.getCurrentBoardHeroList();

            return heroList.map(hero => {
              if (!hero.location || typeof hero.location !== 'string') {
                return null;
              }

              const [x, y] = hero.location.split(',').map(Number);
              const heroData = this.getHeroDataById(hero.hero_id);

              return {
                heroId: hero.hero_id,
                x: x,
                y: y,
                isCore: hero.is_carry_hero || hero.isCore || false,
                isThreeStar: hero.numStar === 3 || hero.isThreeStar || false,
                heroData: heroData
              };
            }).filter(item => item !== null);
          },

          // è®¡ç®—è‹±é›„åœ¨ç«™ä½å›¾ä¸Šçš„ä½ç½®æ ·å¼
          getHeroPositionStyle(x, y) {
            // äº‘é¡¶ä¹‹å¼ˆæ£‹ç›˜æ˜¯4è¡Œ7åˆ—ï¼Œåæ ‡ä»1å¼€å§‹
            // éœ€è¦æ ¹æ®èƒŒæ™¯å›¾çš„å®é™…å°ºå¯¸è®¡ç®—ä½ç½®
            const boardWidth = 100; // èƒŒæ™¯å›¾å®½åº¦ç™¾åˆ†æ¯”
            const boardHeight = 100; // èƒŒæ™¯å›¾é«˜åº¦ç™¾åˆ†æ¯”

            // è®¡ç®—æ¯ä¸ªæ ¼å­çš„å¤§å°ï¼ˆ7åˆ—4è¡Œï¼‰
            const cellWidth = boardWidth / 7;
            const cellHeight = boardHeight / 4;

            // è®¡ç®—ä½ç½®ï¼ˆxæ˜¯è¡Œï¼Œyæ˜¯åˆ—ï¼‰
            const left = (y - 1) * cellWidth + cellWidth / 2;
            const top = (x - 1) * cellHeight + cellHeight / 2;

            return {
              position: 'absolute',
              left: left + '%',
              top: top + '%',
              transform: 'translate(-50%, -50%)'
            };
          },

          // æ˜¾ç¤ºç«™ä½å›¾è‹±é›„æç¤ºæ¡†
          showPositionHeroTooltip(hero, event) {
            if (hero.heroData) {
              this.showHeroTooltip(hero.heroData, event);
            }
          },

          // éšè—ç«™ä½å›¾è‹±é›„æç¤ºæ¡†
          hidePositionHeroTooltip() {
            this.hideHeroTooltip();
          },

          // åˆå§‹åŒ–æ£‹ç›˜æ•°æ® - æ”¯æŒé˜µå®¹æ•°æ®
          initializePositionBoard(lineupData = null) {
            // æ¸…ç©ºå½“å‰ç«™ä½æ•°æ®
            this.currentLineupPositions = [];

            if (lineupData && Array.isArray(lineupData)) {
              // æ ¹æ®ä¼ å…¥çš„é˜µå®¹æ•°æ®è®¾ç½®ç«™ä½
              lineupData.forEach(hero => {
                if (hero.heroId && hero.x && hero.y) {
                  // è·å–è‹±é›„æ•°æ®
                  const heroData = this.getHeroDataById(hero.heroId);
                  if (heroData) {
                    this.currentLineupPositions.push({
                      x: hero.x,
                      y: hero.y,
                      heroId: hero.heroId,
                      heroData: heroData,
                      equipIds: hero.equipIds || [],
                      isCore: hero.isCore || false,
                      isThreeStar: hero.isThreeStar || false
                    });
                  }
                }
              });
            }
          },

          // æ ¹æ®è‹±é›„IDè·å–è‹±é›„æ•°æ®
          getHeroDataById(heroId) {
            if (!this.Data.current.TFTChampionData) return null;
            return this.Data.current.TFTChampionData.find(hero => hero.chessId === heroId);
          },

          // æ£€æŸ¥ä½ç½®æ˜¯å¦è¢«å ç”¨
          isPositionOccupied(row, col) {
            return this.currentLineupPositions.some(pos => pos.x === row && pos.y === col);
          },

          // è·å–æŒ‡å®šä½ç½®çš„è‹±é›„æ•°æ®
          getHeroAtPosition(row, col) {
            return this.currentLineupPositions.find(pos => pos.x === row && pos.y === col);
          },

          // åˆ‡æ¢ä½ç½®çŠ¶æ€ï¼ˆä¿ç•™åŸæœ‰åŠŸèƒ½ï¼Œç”¨äºæ‰‹åŠ¨ç¼–è¾‘ï¼‰
          togglePosition(row, col) {
            const existingHero = this.getHeroAtPosition(row, col);
            if (existingHero) {
              // ç§»é™¤è¯¥ä½ç½®çš„è‹±é›„
              this.currentLineupPositions = this.currentLineupPositions.filter(pos => !(pos.x === row && pos.y === col));
            }
            // æ³¨æ„ï¼šè¿™é‡Œä¸æ·»åŠ æ–°è‹±é›„ï¼Œå› ä¸ºéœ€è¦é€‰æ‹©å…·ä½“çš„è‹±é›„
          },

          // è·å–ä½ç½®ç¼–å·ï¼ˆä¿ç•™åŸæœ‰åŠŸèƒ½ï¼‰
          getPositionNumber(row, col) {
            const hero = this.getHeroAtPosition(row, col);
            return hero ? hero.heroId : '';
          },

          // æ ¹æ®è£…å¤‡IDè·å–è£…å¤‡å›¾ç‰‡
          getEquipImageById(equipId) {
            if (!this.Data.current.TFTEquipData) return '';
            const equip = this.Data.current.TFTEquipData.find(e => e.equipId === equipId);
            return equip ? equip.imagePath : '';
          },

          // æ ¹æ®è£…å¤‡IDè·å–è£…å¤‡åç§°
          getEquipNameById(equipId) {
            if (!this.Data.current.TFTEquipData) return '';
            const equip = this.Data.current.TFTEquipData.find(e => e.equipId === equipId);
            return equip ? equip.name : '';
          },

          // æ ¹æ®è£…å¤‡IDæ˜¾ç¤ºè£…å¤‡æç¤ºæ¡†
          showEquipTooltipById(equipId, event) {
            if (!this.Data.current.TFTEquipData) return;
            const equip = this.Data.current.TFTEquipData.find(e => e.equipId === equipId);
            if (equip) {
              this.showEquipTooltip(equip, event);
            }
          },

          // è·å–æŒ‡å®šä½ç½®çš„è‹±é›„æ•°æ®ï¼ˆåŒ…å«å®Œæ•´çš„è‹±é›„ä¿¡æ¯ï¼‰
          getHeroAtPosition(row, col) {
            const hero = this.currentLineupPositions.find(h => h.x === row && h.y === col);
            if (!hero) return null;

            // è·å–è‹±é›„çš„è¯¦ç»†æ•°æ®
            const heroData = this.getHeroDataById(hero.heroId);

            return {
              ...hero,
              heroData: heroData
            };
          },
          getCurrentBoardHeroList() {
            if (!this.selectedLineup) return [];
            let heroList = [];
            if (this.currentBoardLevel === "l6") {
              heroList = this.selectedLineup.hero_location_l6 || [];
            } else if (this.currentBoardLevel === "l8") {
              heroList = this.selectedLineup.hero_location_l8 || [];
            } else if (this.currentBoardLevel === "l9") {
              heroList = this.selectedLineup.hero_location_l9 || [];

              // å¦‚æœæ˜¯L9é˜¶æ®µä¸”æœ‰x2,y2æ•°æ®ï¼Œæ ¹æ®åæ ‡æ¨¡å¼å¤„ç†æ•°æ®
              if (heroList.length > 0 && heroList[0].hasOwnProperty('x2') && heroList[0].hasOwnProperty('y2')) {
                heroList = heroList.map(hero => {
                  const newHero = { ...hero };

                  if (this.l9CoordinateMode === 'secondary') {
                    // ä½¿ç”¨x2,y2åæ ‡ï¼Œä½†ä¿æŒåŸæœ‰çš„locationæ ¼å¼å…¼å®¹æ€§
                    if (hero.x2 !== undefined && hero.y2 !== undefined && hero.x2 !== 0 && hero.y2 !== 0) {
                      newHero.x = hero.x2;
                      newHero.y = hero.y2;
                      newHero.location = hero.x2 + ',' + hero.y2;
                    }
                  } else {
                    // ä½¿ç”¨ä¸»è¦åæ ‡x,y
                    if (hero.x !== undefined && hero.y !== undefined) {
                      newHero.x = hero.x;
                      newHero.y = hero.y;
                      newHero.location = hero.x + ',' + hero.y;
                    }
                  }

                  return newHero;
                });
              }
            }
            return heroList;
          },

          async fetchDatachushi() {
            this.loading = true;
            this.loadingProgress = 0;

            try {
              this.hero_avatar_xiao ="{{name}}";//åˆ äº†å‡ºbug  å°±è¿™æ ·ç”¨ç€å§
              // ç›´æ¥è¯»å–æœ¬åœ° latestData.json æ–‡ä»¶

              this.loadingMessage = "æ­£åœ¨åŠ è½½æ•°æ®...";
              if (!window.yuanchengdata) {
                console.log("ç­‰å¾…è¿œç¨‹æ•°æ®åŠ è½½...");
                this.loadingMessage = "ç­‰å¾…è¿œç¨‹æ•°æ®...";

                // ç­‰å¾…æ•°æ®åŠ è½½ï¼Œæœ€å¤šç­‰å¾…60ç§’
                let retryCount = 0;
                const maxRetries = 10*60; // 60ç§’ï¼Œæ¯100msæ£€æŸ¥ä¸€æ¬¡

                // ä½¿ç”¨é€’å½’çš„æ–¹å¼æ›¿ä»£whileå¾ªç¯ï¼Œç¡®ä¿UIèƒ½å¤Ÿæ›´æ–°
                const checkData = async () => {
                  if (window.yuanchengdata) {
                    return true;
                  }
                  
                  if (retryCount >= maxRetries) {
                    throw new Error("è¿œç¨‹æ•°æ®åŠ è½½è¶…æ—¶");
                  }
                  
                  retryCount++;
                  // æ›´æ–°åŠ è½½è¿›åº¦æ˜¾ç¤º
                  this.loadingMessage = `ç­‰å¾…è¿œç¨‹æ•°æ®... (${Math.floor(retryCount/10)}s)`;
                  
                  // ä½¿ç”¨Vueçš„nextTickç¡®ä¿UIæ›´æ–°
                  await this.$nextTick();
                  await new Promise(resolve => setTimeout(resolve, 100));
                  
                  return await checkData();
                };
                
                await checkData();
              }
              // æ£€æŸ¥window.yuanchengdataçš„ç±»å‹ï¼Œå¦‚æœå·²ç»æ˜¯å¯¹è±¡åˆ™ç›´æ¥ä½¿ç”¨ï¼Œå¦åˆ™è§£æJSON
              if (typeof window.yuanchengdata === 'string') {
                this.yuanchengdata = JSON.parse(window.yuanchengdata);
              } else {
                this.yuanchengdata = window.yuanchengdata;
              }
              console.log("è¿œç¨‹æ•°æ®æˆåŠŸåŠ è½½...");


              

              // æ£€æŸ¥æ˜¯å¦éœ€è¦æ˜¾ç¤ºèµ›å­£é€‰æ‹©å™¨
              if (this.yuanchengdata.shifoulunhuan) {
                // å‡†å¤‡å¯ç”¨èµ›å­£åˆ—è¡¨
                this.availableSeasons = [];

                if (this.yuanchengdata.currentSeasonInfo && this.yuanchengdata.currentSeasonInfo.stringName) {
                  this.availableSeasons.push({
                    key: 'current',
                    name: this.yuanchengdata.currentSeasonInfo.stringName,
                    data: 'currentSeasonData'
                  });
                }

                if (this.yuanchengdata.rgmSeasonInfo && this.yuanchengdata.rgmSeasonInfo.stringName) {
                  this.availableSeasons.push({
                    key: 'rgm',
                    name: this.yuanchengdata.rgmSeasonInfo.stringName,
                    data: 'rgmSeasonData'
                  });
                }

                // æ˜¾ç¤ºèµ›å­£é€‰æ‹©å™¨
                this.showSeasonSelector = true;
                this.loading = false; // æš‚åœåŠ è½½ï¼Œç­‰å¾…ç”¨æˆ·é€‰æ‹©
                return; // ç­‰å¾…ç”¨æˆ·é€‰æ‹©åå†ç»§ç»­
              } else {
                // ç›´æ¥ä½¿ç”¨currentæ•°æ®
                this.selectedSeason = 'current';
              }

              this.loadSeasonData();
            } catch (err) {
              this.error = err.message;
              this.loadingMessage = "åŠ è½½å¤±è´¥: " + err.message;
              console.error("é”™è¯¯1", this.error);
              console.error("é”™è¯¯2", err);
            } finally {
              this.loadingProgress = 100;
              this.loading = false;
            }
          },

          // åŠ è½½é€‰å®šèµ›å­£çš„æ•°æ®
          loadSeasonData() {
            try {
              if (this.selectedSeason === 'current') {
                // åŠ è½½currentèµ›å­£æ•°æ®
                this.Data.current.TFTChampionData = this.yuanchengdata.currentSeasonData.chessData.data;
                this.Data.current.TFTEquipData = this.yuanchengdata.currentSeasonData.equipData.data;
                this.Data.current.TFTRaceData = this.yuanchengdata.currentSeasonData.raceData.data;
                this.Data.current.TFTJobData = this.yuanchengdata.currentSeasonData.jobData.data;
                this.Data.current.TFTHexData = this.yuanchengdata.currentSeasonData.buffData.data;
                this.Data.current.OPGLineupList = this.yuanchengdata.opGgCompsData;
                this.Data.current.TFTLineupList = this.yuanchengdata.lineupDetaillinelistData;
              } else if (this.selectedSeason === 'rgm') {
                // åŠ è½½rgmèµ›å­£æ•°æ®åˆ°currentä¸­ï¼ˆä½œä¸ºå½“å‰ä½¿ç”¨çš„æ•°æ®ï¼‰
                this.Data.current.TFTChampionData = this.yuanchengdata.rgmSeasonData.chessData.data;
                this.Data.current.TFTEquipData = this.yuanchengdata.rgmSeasonData.equipData.data;
                this.Data.current.TFTRaceData = this.yuanchengdata.rgmSeasonData.raceData.data;
                this.Data.current.TFTJobData = this.yuanchengdata.rgmSeasonData.jobData.data;
                this.Data.current.TFTHexData = this.yuanchengdata.rgmSeasonData.buffData.data;
                this.Data.current.OPGLineupList = this.yuanchengdata.opGgCompsRevivalData; // è½®æ¢æ¨¡å¼ä½¿ç”¨opGgCompsRevivalDataæ•°æ®
                this.Data.current.TFTLineupList = this.yuanchengdata.lineupDetailrgm_lineListData;
              }

              // åŒæ—¶ä¿ç•™rgmæ•°æ®åœ¨rgmå¯¹è±¡ä¸­ï¼ˆç”¨äºå¤‡ä»½æˆ–å…¶ä»–ç”¨é€”ï¼‰
              this.Data.rgm.TFTChampionData = this.yuanchengdata.rgmSeasonData.chessData.data;
              this.Data.rgm.TFTEquipData = this.yuanchengdata.rgmSeasonData.equipData.data;
              this.Data.rgm.TFTRaceData = this.yuanchengdata.rgmSeasonData.raceData.data;
              this.Data.rgm.TFTJobData = this.yuanchengdata.rgmSeasonData.jobData.data;
              this.Data.rgm.TFTHexData = this.yuanchengdata.rgmSeasonData.buffData.data;
              this.Data.rgm.TFTLineupList = this.yuanchengdata.lineupDetailrgm_lineListData;

              // æ¸…ç†åŸå§‹æ•°æ®
              this.yuanchengdata = null;

              // é‡ç½®é˜µå®¹ç›¸å…³çŠ¶æ€ï¼ˆåˆ‡æ¢èµ›å­£æ—¶æ¸…ç©ºä¹‹å‰é€‰ä¸­çš„é˜µå®¹ï¼‰
              this.selectedLineup = null;
              this.showLineupDetail = false;

              // ä»TFTChampionDataåŠ è½½å·²é€‰ä¸­çš„è‹±é›„åˆ°selectedHeroes
              if (this.Data.current && this.Data.current.TFTChampionData) {
                const selectedChampions = this.Data.current.TFTChampionData.filter(h => h.selectednapai);
                this.selectedHeroes = [...selectedChampions];
              }

              // åœ¨æ•°æ®åŠ è½½å®Œæˆåæå–æ‰€æœ‰èŒä¸šå’Œç§æ—
              this.extractJobsAndRaces();

              // é‡æ–°éªŒè¯æ”¶è—æ•°æ®ï¼ˆåœ¨è‹±é›„æ•°æ®åŠ è½½å®Œæˆåï¼‰
              if (this.favoriteLineups.length > 0) {
                this.favoriteLineups = this.validateAndCleanFavorites(this.favoriteLineups);
              }

              // è½®æ¢æ¨¡å¼ç°åœ¨æ”¯æŒOP.GGæ•°æ®ï¼Œç§»é™¤è‡ªåŠ¨åˆ‡æ¢é™åˆ¶
              // if (this.selectedSeason === 'rgm' && this.activeTab === 'opgg') {
              //   this.activeTab = 'tft';
              // }

              // å…³é—­èµ›å­£é€‰æ‹©å™¨
              this.showSeasonSelector = false;
              this.loading = false;

              //console.log(`å·²åŠ è½½ ${this.selectedSeason} èµ›å­£æ•°æ®`);
            } catch (error) {
              console.error('åŠ è½½èµ›å­£æ•°æ®å¤±è´¥:', error);
              this.error = error.message;
              this.loading = false;
            }
          },
          async fetchJsonData(url) {
            try {
              if (!url) {
                console.warn("URLä¸ºç©ºï¼Œæ— æ³•è·å–æ•°æ®");
                return null;
              }

              // é‡ç½®åŠ è½½è¿›åº¦
              this.loadingProgress = 0;
              this.loadingMessage = "æ­£åœ¨è¿æ¥æœåŠ¡å™¨...";

              // ä½¿ç”¨fetch APIå¹¶ç»“åˆResponse.bodyå’ŒReadableStreamæ¥è·å–è¿›åº¦
              const response = await fetch(url, {
                mode: "cors",
                credentials: "same-origin",
                headers: {
                  "Content-Type": "application/json",
                },
                cache: "no-cache",
              });

              if (!response.ok) {
                throw new Error(`è¯·æ±‚å¤±è´¥: ${response.status}`);
              }

              // è·å–å†…å®¹æ€»é•¿åº¦
              const contentLength = response.headers.get('Content-Length');
              const total = contentLength ? parseInt(contentLength, 10) : 0;
              this.loadingMessage = "æ­£åœ¨ä¸‹è½½æ•°æ®...";

              // å¦‚æœæœåŠ¡å™¨æ²¡æœ‰æä¾›å†…å®¹é•¿åº¦ï¼Œåˆ™å›é€€åˆ°æ¨¡æ‹Ÿè¿›åº¦
              if (!total) {
                this.loadingMessage = "æ­£åœ¨å¤„ç†æ•°æ®...";
                return await response.json();
              }

              // è¯»å–å“åº”æµå¹¶è·Ÿè¸ªè¿›åº¦
              const reader = response.body.getReader();
              let receivedLength = 0;
              let chunks = [];

              while (true) {
                const { done, value } = await reader.read();

                if (done) {
                  break;
                }

                chunks.push(value);
                receivedLength += value.length;

                // æ›´æ–°åŠ è½½è¿›åº¦
                this.loadingProgress = Math.min(Math.round((receivedLength / total) * 100), 99);
              }

              // åˆå¹¶æ‰€æœ‰chunkså¹¶è½¬æ¢ä¸ºJSON
              let chunksAll = new Uint8Array(receivedLength);
              let position = 0;
              for (let chunk of chunks) {
                chunksAll.set(chunk, position);
                position += chunk.length;
              }

              const result = new TextDecoder("utf-8").decode(chunksAll);
              this.loadingProgress = 100;
              this.loadingMessage = "æ•°æ®è§£æå®Œæˆ";

              return JSON.parse(result);
            } catch (error) {
              console.error("è·å–æ•°æ®æ—¶å‡ºé”™:", error);
              this.loadingMessage = "åŠ è½½å¤±è´¥: " + error.message;
              throw error;
            }
          },
          showHeroTooltip(hero, event) {
            if (!hero) return;

            // é˜²æŠ–å¤„ç†ï¼šå¦‚æœé¢‘ç¹åˆ‡æ¢ï¼Œå»¶è¿Ÿæ‰§è¡Œ
            if (this.tooltipDebounceTimer) {
              clearTimeout(this.tooltipDebounceTimer);
            }

            // å¦‚æœæ˜¯åŒä¸€ä¸ªè‹±é›„ï¼Œç›´æ¥è¿”å›é¿å…é‡å¤è®¡ç®—
            if (this.tooltipHero && this.tooltipHero.chessId === hero.chessId) {
              return;
            }

            this.tooltipDebounceTimer = setTimeout(() => {
              this.showHeroTooltipInternal(hero, event);
            }, 50); // 50msé˜²æŠ–å»¶è¿Ÿ
          },

          showHeroTooltipInternal(hero, event) {
            // å¢å¼ºè‹±é›„æ•°æ®ï¼Œå°†IDè½¬æ¢ä¸ºå®Œæ•´å¯¹è±¡
            const enhancedHero = { ...hero };



            // å¤„ç†ç§æ—æ•°æ®ï¼šå°†racequansæ•°ç»„è½¬æ¢ä¸ºå®Œæ•´çš„ç§æ—å¯¹è±¡æ•°ç»„
            if (hero.racequans && Array.isArray(hero.racequans) && this.Data.current && this.Data.current.TFTRaceData) {
              enhancedHero.raceId = hero.racequans.map(raceId =>
                this.Data.current.TFTRaceData.find(race => race.raceId === raceId)
              ).filter(Boolean); // è¿‡æ»¤æ‰æ‰¾ä¸åˆ°çš„ç§æ—
            }

            // å¤„ç†èŒä¸šæ•°æ®ï¼šå°†jobquansæ•°ç»„è½¬æ¢ä¸ºå®Œæ•´çš„èŒä¸šå¯¹è±¡æ•°ç»„
            if (hero.jobquans && Array.isArray(hero.jobquans) && this.Data.current && this.Data.current.TFTJobData) {
              enhancedHero.jobId = hero.jobquans.map(jobId =>
                this.Data.current.TFTJobData.find(job => job.jobId === jobId)
              ).filter(Boolean); // è¿‡æ»¤æ‰æ‰¾ä¸åˆ°çš„èŒä¸š
            }

            // å¤„ç†è£…å¤‡æ•°æ®ï¼šå°†opGgItemDataæ•°ç»„è½¬æ¢ä¸ºå®Œæ•´çš„è£…å¤‡å¯¹è±¡æ•°ç»„
            if (hero.opGgItemData && Array.isArray(hero.opGgItemData) && this.Data.current && this.Data.current.TFTEquipData) {
              enhancedHero.equipId = hero.opGgItemData.map(equipId =>
                this.Data.current.TFTEquipData.find(equip => equip.equipId === equipId)
              ).filter(Boolean); // è¿‡æ»¤æ‰æ‰¾ä¸åˆ°çš„è£…å¤‡
            }

            this.tooltipHero = enhancedHero;
            this.tooltipVisible = true;

            // æ£€æµ‹è§¦å‘å…ƒç´ æ‰€åœ¨çš„å®¹å™¨
            let container = '';
            let element = event.target;

            // å‘ä¸ŠæŸ¥æ‰¾çˆ¶å…ƒç´ ï¼Œç¡®å®šæ˜¯å“ªä¸ªå®¹å™¨ä¸­çš„å…ƒç´ è§¦å‘äº†äº‹ä»¶
            while (element) {
              if (element.closest('.avatar-mode-container')) {
                container = 'avatar-mode';
                break;
              } else if (element.closest('.lineup-detail-content')) {
                container = 'top-menu';
                break;
              } else if (element.closest('.position-panel')) {
                container = 'position-panel';
                break;
              }
              if (element.parentElement) {
                element = element.parentElement;
              } else {
                break;
              }
            }

            // è®¾ç½®æ˜¯å¦æ¥è‡ªposition-panelçš„æ ‡è¯†
            this.isPositionPanelTooltip = (container === 'position-panel');

            // è·å–å®¹å™¨ä½ç½®ä»¥è®¡ç®—tooltipä½ç½®
            let x, y;


            if (container === 'avatar-mode') {
              // å¦‚æœæ˜¯avatar-mode-containerä¸­çš„å¤´åƒï¼Œå›ºå®šåœ¨å³ä¾§
              const avatarContainer = document.querySelector('.avatar-mode-container');
              if (avatarContainer) {
                const rect = avatarContainer.getBoundingClientRect();
                x = rect.right; // å®¹å™¨å³ä¾§å¤–10px
                y = rect.top; // ä¸å®¹å™¨é¡¶éƒ¨å¯¹é½
                x = event.clientX + 5;
                y = event.clientY;
              } else {
                // é™çº§å¤„ç†ï¼šå¦‚æœæ‰¾ä¸åˆ°å®¹å™¨ï¼Œä½¿ç”¨é»˜è®¤è¡Œä¸º
                x = event.clientX + 20;
                y = event.clientY - 20;
              }
            } else if (container === 'top-menu') {
              // å¦‚æœæ˜¯top-menu-barä¸­çš„å¤´åƒï¼Œå›ºå®šåœ¨å·¦ä¾§
              const menuBar = document.querySelector('.top-menu-bar');
              if (menuBar) {
                const rect = menuBar.getBoundingClientRect();
                const fontSize = parseFloat(getComputedStyle(document.documentElement).fontSize);
                //å­—ä½“ä¹˜2.6

                x = event.clientX - fontSize * 3;
                y = event.clientY;

              } else {
                // é™çº§å¤„ç†
                x = event.clientX + 20;
                y = event.clientY - 20;
              }
            } else if (container === 'position-panel') {
              // å¦‚æœæ˜¯position-panelä¸­çš„å¤´åƒï¼Œå›ºå®šåœ¨å³ä¾§ä½ç½®
              const positionPanel = document.querySelector('.position-panel');

              if (positionPanel) {
                const fontSize2 = parseFloat(getComputedStyle(document.documentElement).fontSize);


                this.$nextTick(() => {
                  const tooltipElement = document.querySelector('.hero-tooltip');
                  if (tooltipElement) {
                    const rect = tooltipElement.getBoundingClientRect();

                    y = 11.8 * fontSize2 - rect.height; // é¢æ¿å³ä¾§å¤–10px
                    x = 19.95 * fontSize2; // é¢æ¿é¡¶éƒ¨ä¸‹50px
                  }
                });



              } else {
                // é™çº§å¤„ç†
                x = event.clientX + 20;
                y = event.clientY - 20;
              }
            } else {
              // é»˜è®¤è¡Œä¸ºï¼šè·Ÿéšé¼ æ ‡
              x = event.clientX + 20;
              y = event.clientY - 20;
            }

            // åŸºç¡€è¾¹ç•Œæ£€æŸ¥ï¼ˆä½¿ç”¨åŠ¨æ€å°ºå¯¸è¿›è¡Œç²¾ç¡®è°ƒæ•´ï¼‰
            if (x < 0) x = 10;
            if (y < 0) y = 10;

            // å…ˆè®¾ç½®åˆå§‹ä½ç½®
            this.tooltipX = x;
            this.tooltipY = y;

            // ä½¿ç”¨nextTickç¡®ä¿DOMæ›´æ–°åè·å–å®é™…å°ºå¯¸å¹¶è°ƒæ•´ä½ç½®
            this.$nextTick(() => {
              const tooltipElement = document.querySelector('.hero-tooltip');
              if (tooltipElement) {
                const rect = tooltipElement.getBoundingClientRect();
                const actualWidth = rect.width;
                const actualHeight = rect.height;

                // é‡æ–°è®¡ç®—ä½ç½®ï¼Œé˜²æ­¢è¶…å‡ºçª—å£è¾¹ç•Œ
                let adjustedX = x;
                let adjustedY = y;

                if (adjustedX + actualWidth > window.innerWidth) {
                  adjustedX = window.innerWidth - actualWidth - 10;
                }
                if (adjustedX < 0) adjustedX = 10;

                if (adjustedY + actualHeight > window.innerHeight) {
                  adjustedY = window.innerHeight - actualHeight - 10;
                }
                if (adjustedY < 0) adjustedY = 10;

                // æ›´æ–°æœ€ç»ˆä½ç½®
                this.tooltipX = adjustedX;
                this.tooltipY = adjustedY;
              }
            });
          },
          hideHeroTooltip() {
            // æ¸…ç†é˜²æŠ–å®šæ—¶å™¨
            if (this.tooltipDebounceTimer) {
              clearTimeout(this.tooltipDebounceTimer);
              this.tooltipDebounceTimer = null;
            }
            
            this.tooltipVisible = false;
            this.tooltipHero = null;
            this.isPositionPanelTooltip = false; // é‡ç½®position-panelæ ‡è¯†
          },
          toggleTopMenu(menu) {
            this.topMenu = this.topMenu === menu ? '' : menu;

            // å½“data-lineupæ¶ˆå¤±æ—¶ï¼Œè‡ªåŠ¨å…³é—­filter-panel
            if (this.topMenu !== 'lineup') {
              this.showFilterPanel = false;
            }
          },

          // åˆ‡æ¢æ ‡ç­¾é¡µå¹¶é‡ç½®æ»šåŠ¨æ¡
          switchTab(tabName) {
            // è½®æ¢æ¨¡å¼ç°åœ¨æ”¯æŒOP.GGæ•°æ®ï¼Œç§»é™¤é™åˆ¶
            // if (this.isRgmSeason && tabName === 'opgg') {
            //   tabName = 'tft';
            // }

            this.activeTab = tabName;

            // é‡ç½®æ»šåŠ¨æ¡åˆ°é¡¶éƒ¨
            this.$nextTick(() => {
              const tabContent = document.querySelector('.tab-content');
              if (tabContent) {
                tabContent.scrollTop = 0;
              }
            });
          },

          // åˆ‡æ¢æ˜¾ç¤ºå…¨éƒ¨æ”¶è—é˜µå®¹
          toggleShowAllFavorites() {
            this.showAllFavorites = !this.showAllFavorites;

            // åˆ‡æ¢åé‡ç½®æ»šåŠ¨æ¡åˆ°é¡¶éƒ¨
            this.$nextTick(() => {
              const tabContent = document.querySelector('.tab-content');
              if (tabContent) {
                tabContent.scrollTop = 0;
              }
            });
          },

          // ç¡®è®¤èµ›å­£é€‰æ‹©
          confirmSeasonSelection() {
            if (!this.selectedSeason) return;

            this.loading = true;
            this.loadingMessage = `æ­£åœ¨åŠ è½½${this.selectedSeason === 'current' ? 'å½“å‰' : 'ä¸Šä¸ª'}èµ›å­£æ•°æ®...`;

            // å»¶è¿Ÿä¸€ä¸‹è®©ç”¨æˆ·çœ‹åˆ°åŠ è½½çŠ¶æ€
            setTimeout(() => {
              this.loadSeasonData();
            }, 500);
          },
          showTooltipText(text, event) {
            this.simpleTooltipText = text;
            this.simpleTooltipVisible = true;

            // è®¡ç®—æç¤ºæ¡†ä½ç½®
            const x = event.clientX + 15;
            const y = event.clientY - 10;

            // é˜²æ­¢è¶…å‡ºçª—å£
            const maxX = window.innerWidth - 150;
            const maxY = window.innerHeight - 50;

            this.simpleTooltipStyle = {
              top: Math.min(y, maxY) + 'px',
              left: Math.min(x, maxX) + 'px',
              position: 'fixed',
              zIndex: 9999
            };
          },
          hideTooltipText() {
            this.simpleTooltipVisible = false;
          },
          showEquipTooltip(equip, event) {
            // ç¡®ä¿æç¤ºæ¡†å¤„ç†å„ç§å¯èƒ½çš„è£…å¤‡æ•°æ®æ ¼å¼
            if (!equip) return; // é˜²æ­¢ç©ºæ•°æ®é”™è¯¯

            // é˜²æŠ–å¤„ç†
            if (this.equipTooltipDebounceTimer) {
              clearTimeout(this.equipTooltipDebounceTimer);
            }

            // å¦‚æœæ˜¯åŒä¸€ä¸ªè£…å¤‡ï¼Œç›´æ¥è¿”å›
            if (this.currentEquip && this.currentEquip.name === (equip.name || equip.displayName)) {
              return;
            }

            this.equipTooltipDebounceTimer = setTimeout(() => {
              this.showEquipTooltipInternal(equip, event);
            }, 50);
          },

          showEquipTooltipInternal(equip, event) {

            this.currentEquip = {
              name: equip.name || equip.displayName || 'æœªçŸ¥è£…å¤‡',
              imagePath: equip.imagePath || equip.imageUrl || '',
              effect: equip.effect || equip.description || equip.desc || 'æ— æè¿°',
              formula: equip.formula || equip.recipe || ''
            };

            this.equipTooltipVisible = true;

            // ä½¿ç”¨å›ºå®šå®½åº¦å’Œä¼°è®¡é«˜åº¦

            const fontSize = parseFloat(getComputedStyle(document.documentElement).fontSize);
            //å­—ä½“ä¹˜2.6


            const tooltipWidth = fontSize * 3; // å¢åŠ å®½åº¦é¢„ä¼°å€¼ï¼Œç¡®ä¿è¶³å¤Ÿ
            const tooltipHeight = 300;

            // å§‹ç»ˆä¼˜å…ˆæ˜¾ç¤ºåœ¨é¼ æ ‡å·¦ä¾§ï¼Œé¿å…å³ä¾§æº¢å‡º
            let x = event.clientX - tooltipWidth - 20; // é»˜è®¤å·¦ä¾§åç§»æ›´å¤š
            let y = event.clientY - 50;

            // å¦‚æœå·¦ä¾§ç©ºé—´ä¸è¶³ï¼Œåˆ™å°è¯•æ”¾åœ¨å³ä¾§
            if (x < 10) {
              x = event.clientX + 20;
              // å¦‚æœå³ä¾§ä¹Ÿæ”¾ä¸ä¸‹ï¼Œåˆ™å¼ºåˆ¶é å·¦æ˜¾ç¤ºå¹¶ç¡®ä¿ä¸è¶…å‡ºå·¦è¾¹ç•Œ
              if (x + tooltipWidth > window.innerWidth - 10) {
                x = 10; // é å·¦æ˜¾ç¤º
              }
            }

            // é˜²æ­¢è¶…å‡ºçª—å£å³ä¾§è¾¹ç•Œï¼Œè¿™æ˜¯ä¸€ä¸ªé¢å¤–çš„æ£€æŸ¥
            if (x + tooltipWidth > window.innerWidth - 10) {
              x = window.innerWidth - tooltipWidth - 10;
            }

            // é˜²æ­¢è¶…å‡ºçª—å£åº•éƒ¨
            if (y + tooltipHeight > window.innerHeight - 10) {
              y = window.innerHeight - tooltipHeight - 10;
            }

            // é˜²æ­¢è¶…å‡ºçª—å£é¡¶éƒ¨
            if (y < 10) {
              y = 10;
            }

            this.equipTooltipStyle = {
              top: y + 'px',
              left: x + 'px',
              position: 'fixed',
              zIndex: 9999,
              maxWidth: (tooltipWidth - 20) + 'px' // è®¾ç½®æœ€å¤§å®½åº¦ç¡®ä¿å†…å®¹ä¸ä¼šè¶…å‡º
            };
          },
          hideEquipTooltip() {
            // æ¸…ç†è£…å¤‡æç¤ºé˜²æŠ–å®šæ—¶å™¨
            if (this.equipTooltipDebounceTimer) {
              clearTimeout(this.equipTooltipDebounceTimer);
              this.equipTooltipDebounceTimer = null;
            }
            
            this.equipTooltipVisible = false;
          },
          // æµ·å…‹æ–¯æ‚¬æµ®æç¤ºæ¡†æ–¹æ³•
          showHexTooltip(hex, event) {
            if (!hex) return;

            // å¦‚æœä¼ å…¥çš„æ˜¯å­—ç¬¦ä¸²IDï¼Œå…ˆå°è¯•è·å–æµ·å…‹æ–¯æ•°æ®
            let hexData = null;
            if (typeof hex === 'string') {
              hexData = this.getHexById(hex);
              if (!hexData) {
                // å¦‚æœæ‰¾ä¸åˆ°æ•°æ®ï¼Œåˆ›å»ºä¸€ä¸ªé»˜è®¤å¯¹è±¡
                hexData = {
                  hexId: hex,
                  name: `æµ·å…‹æ–¯ ${hex}`,
                  imagePath: '',
                  imgUrl: '',
                  description: 'æš‚æ— æè¿°ä¿¡æ¯',
                  introduce: ''
                };
              }
            } else {
              // å¦‚æœä¼ å…¥çš„æ˜¯å¯¹è±¡ï¼Œè·å–è¯¦ç»†ä¿¡æ¯
              hexData = this.getHexById(hex.hexId || hex.id) || hex;
            }

            this.currentHex = {
              name: (hexData && hexData.name) || 'æœªçŸ¥æµ·å…‹æ–¯',
              imagePath: (hexData && hexData.imagePath) || (hexData && hexData.imgUrl) || '',
              imgUrl: (hexData && hexData.imgUrl) || (hexData && hexData.imagePath) || '',
              description: (hexData && hexData.description) || (hexData && hexData.introduce) || 'æ— æè¿°',
              introduce: (hexData && hexData.introduce) || (hexData && hexData.description) || ''
            };

            this.hexTooltipVisible = true;

            // è®¡ç®—æç¤ºæ¡†ä½ç½®
            const fontSize = parseFloat(getComputedStyle(document.documentElement).fontSize);
            const tooltipWidth = fontSize * 3;
            const tooltipHeight = 200;

            let x = event.clientX - tooltipWidth - 20;
            let y = event.clientY - 50;

            if (x < 10) {
              x = event.clientX + 20;
              if (x + tooltipWidth > window.innerWidth - 10) {
                x = 10;
              }
            }

            if (x + tooltipWidth > window.innerWidth - 10) {
              x = window.innerWidth - tooltipWidth - 10;
            }

            if (y + tooltipHeight > window.innerHeight - 10) {
              y = window.innerHeight - tooltipHeight - 10;
            }

            if (y < 10) {
              y = 10;
            }

            this.hexTooltipStyle = {
              top: y + 'px',
              left: x + 'px',
              position: 'fixed',
              zIndex: 9999,
              maxWidth: (tooltipWidth - 20) + 'px'
            };
          },
          hideHexTooltip() {
            this.hexTooltipVisible = false;
          },
          // æµ·å…‹æ–¯é€‰æ‹©æ‚¬æµ®æç¤ºæ–¹æ³•
          showHexStrategyTooltip(event) {
            this.hexStrategyTooltipVisible = true;
          },
          hideHexStrategyTooltip() {
            this.hexStrategyTooltipVisible = false;
          },
          // å‰æœŸè¿‡åº¦æ‚¬æµ®æç¤ºæ–¹æ³•
          showEarlyStrategyTooltip(event) {
            this.earlyStrategyTooltipVisible = true;
          },
          hideEarlyStrategyTooltip() {
            this.earlyStrategyTooltipVisible = false;
          },
          // è£…å¤‡æ­é…æ‚¬æµ®æç¤ºæ–¹æ³•
          showEquipmentStrategyTooltip(event) {
            this.equipmentStrategyTooltipVisible = true;
          },
          hideEquipmentStrategyTooltip() {
            this.equipmentStrategyTooltipVisible = false;
          },
          // ç«™ä½æŠ€å·§æ‚¬æµ®æç¤ºæ–¹æ³•
          showPositionStrategyTooltip(event) {
            this.positionStrategyTooltipVisible = true;
          },
          hidePositionStrategyTooltip() {
            this.positionStrategyTooltipVisible = false;
          },
          getPositionInfo() {
            if (!this.selectedLineup) return null;
            if (this.l9CoordinateMode === 'secondary' && this.selectedLineup.location_info2) {
              return this.selectedLineup.location_info2;
            }
            return this.selectedLineup.location_info;
          },
          getEquipName(equipId) {
            if (!this.Data.current.TFTEquipData) return "";
            const equip = this.Data.current.TFTEquipData.find(
              (e) => e.equipId === equipId
            );
            return equip ? equip.name : "";
          },
          formatEquipDescription(effect) {
            if (!effect) return '';

            // ç§»é™¤å±æ€§æ•°å€¼éƒ¨åˆ†ï¼Œä¿ç•™ä¸»è¦æ•ˆæœæè¿°
            let description = effect;



            // æ›¿æ¢\r\nä¸º<br>
            description = description.replace(/\r\n\r\n\r\n\r\n/g, '<br><br>');
            description = description.replace(/\r\n/g, '<br>');

            // ç§»é™¤å¼€å¤´çš„ç©ºç™½å’Œ<br>
            description = description.replace(/^(<br>)+/, '');

            return description;
          },
          selectHero(hero) {


            // æŸ¥æ‰¾è‹±é›„æ˜¯å¦å·²ç»åœ¨é€‰ä¸­åˆ—è¡¨ä¸­
            const index = this.selectedHeroes.findIndex(h => h.chessId === hero.chessId);

            if (index !== -1) {
              this.selectedHeroes.splice(index, 1);
            } else {
              this.selectedHeroes.push(hero);
            }
          },
          isHeroSelected(chessId) {
            return this.selectedHeroes.some(hero => hero.chessId === chessId);
          },
          toggleFilterPanel(event) {
            // å¦‚æœæ‰“å¼€é¢æ¿ï¼Œè®°å½•é¼ æ ‡ä½ç½®
            if (!this.showFilterPanel) {
              // ä¿å­˜ç‚¹å‡»ä½ç½®
              this.filterPanelX = event.clientX;
              this.filterPanelY = event.clientY;

              // æ·»åŠ ä¸€ä¸ªå»¶è¿Ÿï¼Œç¡®ä¿åœ¨æ ·å¼åº”ç”¨åå†è®¾ç½®ä½ç½®
              setTimeout(() => {
                const panel = document.querySelector('.filter-panel');
                if (panel) {

                  // è®¾ç½®é¢æ¿ä½ç½®ï¼Œç¨å¾®åç§»ä»¥é¿å…é®æŒ¡æŒ‰é’®
                  panel.style.left = (this.filterPanelX - 20) + 'px';
                  panel.style.top = (this.filterPanelY + 20) + 'px';
                }
              }, 0);
            }

            // åˆ‡æ¢ç­›é€‰é¢æ¿çš„æ˜¾ç¤ºçŠ¶æ€
            this.showFilterPanel = !this.showFilterPanel;
          },
          // åˆ‡æ¢èŒä¸šé€‰æ‹©çŠ¶æ€
          toggleJobFilter(job) {
            const index = this.selectedJobs.indexOf(job);
            if (index === -1) {
              this.selectedJobs.push(job);
            } else {
              this.selectedJobs.splice(index, 1);
            }
          },

          // åˆ‡æ¢ç§æ—/ç¾ç»Šé€‰æ‹©çŠ¶æ€
          toggleRaceFilter(race) {
            const index = this.selectedRaces.indexOf(race);
            if (index === -1) {
              this.selectedRaces.push(race);
            } else {
              this.selectedRaces.splice(index, 1);
            }
          },

          // åˆ‡æ¢ç­‰çº§é€‰æ‹©çŠ¶æ€
          toggleTierFilter(tier) {
            const index = this.selectedTiers.indexOf(tier);
            if (index === -1) {
              this.selectedTiers.push(tier);
            } else {
              this.selectedTiers.splice(index, 1);
            }
          },

          // é‡ç½®æ‰€æœ‰ç­›é€‰æ¡ä»¶
          resetAllFilters() {
            this.searchText = '';
            this.selectedJobs = [];
            this.selectedRaces = [];
            this.selectedTiers = [];
            this.showFilterPanel = false;
          },

          // åœ¨åŠ è½½æ•°æ®åæå–æ‰€æœ‰èŒä¸šå’Œç§æ—
          extractJobsAndRaces() {
            const result = this.uniqueJobsAndRaces;
            this.allJobs = result.jobs;
            this.allRaces = result.races;
          },

          // æ”¶è—ç›¸å…³æ–¹æ³•
          // æ£€æŸ¥é˜µå®¹æ˜¯å¦å·²æ”¶è—
          isLineupFavorited(lineup) {
            return this.favoriteLineups.some(fav => fav.id === lineup.id);
          },

          // åˆ‡æ¢æ”¶è—çŠ¶æ€
          toggleFavorite(lineup) {
            const index = this.favoriteLineups.findIndex(fav => fav.id === lineup.id);

            if (index !== -1) {
              // å–æ¶ˆæ”¶è— - æ·»åŠ äºŒæ¬¡ç¡®è®¤
              this.showConfirmDialog(
                'ç¡®è®¤å–æ¶ˆæ”¶è—',
                `ç¡®å®šè¦å–æ¶ˆæ”¶è—é˜µå®¹"${lineup.name}"å—ï¼Ÿ`,
                () => {
                  this.favoriteLineups.splice(index, 1);
                  this.saveFavoritesToFile(); // ç«‹å³ä¿å­˜
                  //console.log('å–æ¶ˆæ”¶è—:', lineup.name, 'ID:', lineup.id);
                }
              );
              return; // ç­‰å¾…ç”¨æˆ·ç¡®è®¤ï¼Œä¸ç»§ç»­æ‰§è¡Œåç»­ä»£ç 
            } else {
              // æ·»åŠ æ”¶è— - å…ˆå‹ç¼©æ•°æ®
              const compressedLineup = this.compressLineupData(lineup);
              compressedLineup.favoriteTime = new Date().toISOString(); // æ·»åŠ æ”¶è—æ—¶é—´

              // ä¸´æ—¶æ·»åŠ åˆ°æ•°ç»„ä¸­ä»¥æ£€æŸ¥å¤§å°
              const tempFavorites = [...this.favoriteLineups, compressedLineup];
              const tempData = {
                version: "1.0",
                lastUpdated: new Date().toISOString(),
                count: tempFavorites.length,
                favorites: tempFavorites
              };

              // æ£€æŸ¥å­˜å‚¨å¤§å°ï¼ˆ4MB = 4 * 1024 * 1024 bytesï¼‰
              const dataSize = new Blob([JSON.stringify(tempData)]).size;
              const maxSize = 4 * 1024 * 1024; // 4MB

              if (dataSize > maxSize) {
                const sizeMB = (dataSize / (1024 * 1024)).toFixed(2);
                this.showWarningDialog(
                  'å­˜å‚¨ç©ºé—´ä¸è¶³',
                  `å½“å‰æ”¶è—æ•°æ®å¤§å°ï¼š${sizeMB}MB<br>æœ€å¤§é™åˆ¶ï¼š4MB<br><br>è¯·å…ˆå–æ¶ˆä¸€äº›æ”¶è—çš„é˜µå®¹ï¼Œç„¶åå†æ”¶è—æ–°çš„é˜µå®¹ã€‚`
                );
                return;
              }

              // æ·»åŠ æ”¶è—å¹¶æŒ‰æ—¶é—´æ’åºï¼ˆæœ€æ–°çš„åœ¨å‰é¢ï¼‰
              this.favoriteLineups.push(compressedLineup);
              this.sortFavoritesByTime();
              //console.log('æ·»åŠ æ”¶è—:', lineup.name, 'ID:', lineup.id);
            }

            // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
            this.saveFavoritesToFile();
          },

          // å‹ç¼©é˜µå®¹æ•°æ® - å°†chessDataå’ŒequipDataè½¬æ¢ä¸ºå¼•ç”¨ID
          compressLineupData(lineup) {
            const compressed = { ...lineup };

            // å‹ç¼©L6é˜µå®¹æ•°æ®
            if (compressed.hero_location_l6) {
              compressed.hero_location_l6 = compressed.hero_location_l6.map(hero => ({
                ...hero,
                heroId: hero.chessData ? hero.chessData.chessId : null, // åªä¿å­˜è‹±é›„ID
                equipIds: hero.equipData ? hero.equipData.map(equip => equip.equipId) : [], // åªä¿å­˜è£…å¤‡IDæ•°ç»„
                // ç§»é™¤åŸå§‹çš„å®Œæ•´æ•°æ®
                chessData: undefined,
                equipData: undefined
              }));
            }

            // å‹ç¼©L8é˜µå®¹æ•°æ®
            if (compressed.hero_location_l8) {
              compressed.hero_location_l8 = compressed.hero_location_l8.map(hero => ({
                ...hero,
                heroId: hero.chessData ? hero.chessData.chessId : null,
                equipIds: hero.equipData ? hero.equipData.map(equip => equip.equipId) : [],
                chessData: undefined,
                equipData: undefined
              }));
            }

            // å‹ç¼©L9é˜µå®¹æ•°æ®
            if (compressed.hero_location_l9) {
              compressed.hero_location_l9 = compressed.hero_location_l9.map(hero => ({
                ...hero,
                heroId: hero.chessData ? hero.chessData.chessId : null,
                equipIds: hero.equipData ? hero.equipData.map(equip => equip.equipId) : [],
                chessData: undefined,
                equipData: undefined
              }));
            }

            return compressed;
          },

          // è§£å‹ç¼©é˜µå®¹æ•°æ® - ä»å¼•ç”¨IDæ¢å¤å®Œæ•´çš„chessDataå’ŒequipData
          decompressLineupData(compressedLineup) {
            const decompressed = { ...compressedLineup };

            // è§£å‹ç¼©L6é˜µå®¹æ•°æ®
            if (decompressed.hero_location_l6) {
              decompressed.hero_location_l6 = decompressed.hero_location_l6.map(hero => {
                const restoredHero = { ...hero };

                // æ¢å¤chessData
                if (hero.heroId && this.Data.current.TFTChampionData) {
                  restoredHero.chessData = this.Data.current.TFTChampionData.find(
                    chess => chess.chessId === hero.heroId
                  );

                  // æ·»åŠ è°ƒè¯•ä¿¡æ¯ï¼Œæ£€æŸ¥æ¢å¤çš„æ•°æ®
                  if (!restoredHero.chessData) {
                    //console.warn(`æ— æ³•æ‰¾åˆ°è‹±é›„æ•°æ®ï¼ŒheroId: ${hero.heroId}`);
                  } else if (!restoredHero.chessData.name) {
                    console.warn(`è‹±é›„æ•°æ®ç¼ºå°‘nameå­—æ®µ:`, restoredHero.chessData);
                  } else {
                    ////console.log(`æˆåŠŸæ¢å¤è‹±é›„æ•°æ®: ${restoredHero.chessData.displayName || restoredHero.chessData.name}`);
                  }
                }

                // æ¢å¤equipData
                if (hero.equipIds && hero.equipIds.length > 0 && this.Data.current.TFTEquipData) {
                  restoredHero.equipData = hero.equipIds.map(equipId =>
                    this.Data.current.TFTEquipData.find(equip => equip.equipId === equipId)
                  ).filter(Boolean); // è¿‡æ»¤æ‰æ‰¾ä¸åˆ°çš„è£…å¤‡
                }

                // æ¸…ç†ä¸´æ—¶å­—æ®µ
                delete restoredHero.heroId;
                delete restoredHero.equipIds;

                return restoredHero;
              });
            }

            // è§£å‹ç¼©L8é˜µå®¹æ•°æ®
            if (decompressed.hero_location_l8) {
              decompressed.hero_location_l8 = decompressed.hero_location_l8.map(hero => {
                const restoredHero = { ...hero };

                if (hero.heroId && this.Data.current.TFTChampionData) {
                  restoredHero.chessData = this.Data.current.TFTChampionData.find(
                    chess => chess.chessId === hero.heroId
                  );

                  // æ·»åŠ è°ƒè¯•ä¿¡æ¯ï¼Œæ£€æŸ¥æ¢å¤çš„æ•°æ®
                  if (!restoredHero.chessData) {
                    //console.warn(`æ— æ³•æ‰¾åˆ°è‹±é›„æ•°æ®ï¼ŒheroId: ${hero.heroId}`);
                  } else if (!restoredHero.chessData.name) {
                    console.warn(`è‹±é›„æ•°æ®ç¼ºå°‘nameå­—æ®µ:`, restoredHero.chessData);
                  } else {
                    ////console.log(`æˆåŠŸæ¢å¤è‹±é›„æ•°æ®: ${restoredHero.chessData.displayName || restoredHero.chessData.name}`);
                  }
                }

                if (hero.equipIds && hero.equipIds.length > 0 && this.Data.current.TFTEquipData) {
                  restoredHero.equipData = hero.equipIds.map(equipId =>
                    this.Data.current.TFTEquipData.find(equip => equip.equipId === equipId)
                  ).filter(Boolean);
                }

                delete restoredHero.heroId;
                delete restoredHero.equipIds;

                return restoredHero;
              });
            }

            // è§£å‹ç¼©L9é˜µå®¹æ•°æ®
            if (decompressed.hero_location_l9) {
              decompressed.hero_location_l9 = decompressed.hero_location_l9.map(hero => {
                const restoredHero = { ...hero };

                if (hero.heroId && this.Data.current.TFTChampionData) {
                  restoredHero.chessData = this.Data.current.TFTChampionData.find(
                    chess => chess.chessId === hero.heroId
                  );

                  // æ·»åŠ è°ƒè¯•ä¿¡æ¯ï¼Œæ£€æŸ¥æ¢å¤çš„æ•°æ®
                  if (!restoredHero.chessData) {
                    //console.warn(`æ— æ³•æ‰¾åˆ°è‹±é›„æ•°æ®ï¼ŒheroId: ${hero.heroId}`);
                  } else if (!restoredHero.chessData.name) {
                    console.warn(`è‹±é›„æ•°æ®ç¼ºå°‘nameå­—æ®µ:`, restoredHero.chessData);
                  } else {
                    ////console.log(`æˆåŠŸæ¢å¤è‹±é›„æ•°æ®: ${restoredHero.chessData.displayName || restoredHero.chessData.name}`);
                  }
                }

                if (hero.equipIds && hero.equipIds.length > 0 && this.Data.current.TFTEquipData) {
                  restoredHero.equipData = hero.equipIds.map(equipId =>
                    this.Data.current.TFTEquipData.find(equip => equip.equipId === equipId)
                  ).filter(Boolean);
                }

                delete restoredHero.heroId;
                delete restoredHero.equipIds;

                return restoredHero;
              })
            }

            // ç”Ÿæˆhero_races_l9å’Œhero_jobs_l9å­—æ®µç”¨äºç­›é€‰åŠŸèƒ½
            if (decompressed.hero_location_l9) {
              const raceNames = [];
              const jobNames = [];

              decompressed.hero_location_l9.forEach(hero => {
                if (hero.chessData) {
                  // æ”¶é›†ç§æ—åç§°
                  if (hero.chessData.racequans && Array.isArray(hero.chessData.racequans)) {
                    hero.chessData.racequans.forEach(raceId => {
                      if (this.Data.current && this.Data.current.TFTRaceData) {
                        const race = this.Data.current.TFTRaceData.find(r => r.raceId === raceId);
                        if (race && race.name && !raceNames.includes(race.name)) {
                          raceNames.push(race.name);
                        }
                      }
                    });
                  }

                  // æ”¶é›†èŒä¸šåç§°
                  if (hero.chessData.jobquans && Array.isArray(hero.chessData.jobquans)) {
                    hero.chessData.jobquans.forEach(jobId => {
                      if (this.Data.current && this.Data.current.TFTJobData) {
                        const job = this.Data.current.TFTJobData.find(j => j.jobId === jobId);
                        if (job && job.name && !jobNames.includes(job.name)) {
                          jobNames.push(job.name);
                        }
                      }
                    });
                  }
                }
              });

              // æ›´æ–°hero_races_l9å’Œhero_jobs_l9å­—æ®µ
              decompressed.hero_races_l9 = raceNames.join(',');
              decompressed.hero_jobs_l9 = jobNames.join(',');
            }

            return decompressed;
          },

          // è·å–å½“å‰èµ›å­£æ ‡è¯†
          getCurrentSeason() {
            // ä»å½“å‰ä½¿ç”¨çš„ç¬¬ä¸€ä¸ªé˜µå®¹è·å–èµ›å­£ä¿¡æ¯
            let currentSeason = null;

            // ä¼˜å…ˆä»OP.GGé˜µå®¹è·å–
            if (this.Data.current.OPGLineupList && this.Data.current.OPGLineupList.length > 0) {
              currentSeason = this.Data.current.OPGLineupList[0].saiji;
            }
            // å¦‚æœOP.GGæ²¡æœ‰ï¼Œä»å®˜æ–¹é˜µå®¹è·å–
            else if (this.Data.current.TFTLineupList && this.Data.current.TFTLineupList.length > 0) {
              currentSeason = this.Data.current.TFTLineupList[0].saiji;
            }

            return currentSeason;
          },

          // æ ¹æ®èµ›å­£è¿‡æ»¤æ”¶è—é˜µå®¹
          filterFavoritesBySeason(favoriteLineups) {
            const currentSeason = this.getCurrentSeason();

            // å¦‚æœæ— æ³•è·å–å½“å‰èµ›å­£ï¼Œè¿”å›æ‰€æœ‰æ”¶è—é˜µå®¹
            if (!currentSeason) {
              console.warn('æ— æ³•è·å–å½“å‰èµ›å­£ä¿¡æ¯ï¼Œæ˜¾ç¤ºæ‰€æœ‰æ”¶è—é˜µå®¹');
              return favoriteLineups;
            }

            // è¿‡æ»¤å‡ºä¸å½“å‰èµ›å­£åŒ¹é…çš„æ”¶è—é˜µå®¹
            const filteredFavorites = favoriteLineups.filter(lineup => {
              // å¦‚æœæ”¶è—é˜µå®¹æ²¡æœ‰èµ›å­£ä¿¡æ¯ï¼Œä¹Ÿæ˜¾ç¤ºï¼ˆå…¼å®¹æ—§æ•°æ®ï¼‰
              if (!lineup.saiji) {
                return false;
              }

              // æ¯”è¾ƒèµ›å­£æ˜¯å¦åŒ¹é…
              return lineup.saiji === currentSeason;
            });

            // åœ¨æ§åˆ¶å°è¾“å‡ºè¿‡æ»¤ä¿¡æ¯
            if (filteredFavorites.length !== favoriteLineups.length) {
              //console.log(`å½“å‰èµ›å­£: ${currentSeason}`);
              //console.log(`æ”¶è—é˜µå®¹æ€»æ•°: ${favoriteLineups.length}, å½“å‰èµ›å­£åŒ¹é…: ${filteredFavorites.length}`);

              // ç»Ÿè®¡ä¸åŒèµ›å­£çš„æ”¶è—æ•°é‡
              const seasonStats = {};
              favoriteLineups.forEach(lineup => {
                const season = lineup.saiji || 'æœªçŸ¥èµ›å­£';
                seasonStats[season] = (seasonStats[season] || 0) + 1;
              });
              //console.log('å„èµ›å­£æ”¶è—ç»Ÿè®¡:', seasonStats);
            }

            return filteredFavorites;
          },

          // ä¿å­˜æ”¶è—åˆ°æœ¬åœ°æ–‡ä»¶ï¼ˆCEFåº”ç”¨ä¸“ç”¨ï¼‰
          async saveFavoritesToFile() {
            try {
              const favoritesData = {
                version: "1.0",
                lastUpdated: new Date().toISOString(),
                count: this.favoriteLineups.length,
                favorites: this.favoriteLineups
              };

              // ä¸»è¦æ–¹æ¡ˆï¼šä½¿ç”¨ localStorage å­˜å‚¨
              localStorage.setItem('tft_favorite_lineups', JSON.stringify(favoritesData));
              //console.log('æ”¶è—æ•°æ®å·²ä¿å­˜åˆ° localStorage');

            } catch (error) {
              console.error('ä¿å­˜æ”¶è—åˆ°localStorageå¤±è´¥:', error);
              // å¦‚æœlocalStorageå¤±è´¥ï¼Œæ˜¾ç¤ºé”™è¯¯æç¤º
              this.showErrorDialog('ä¿å­˜å¤±è´¥', 'ä¿å­˜æ”¶è—å¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨å­˜å‚¨æƒé™');
            }
          },

          // ä»æœ¬åœ°å­˜å‚¨åŠ è½½æ”¶è—ï¼ˆä¸»è¦æ–¹æ¡ˆï¼šlocalStorageï¼‰
          async loadFavoritesFromFile() {
            try {
              const saved = localStorage.getItem('tft_favorite_lineups');
              if (saved) {
                const data = JSON.parse(saved);

                // éªŒè¯æ–‡ä»¶æ ¼å¼
                if (data.favorites && Array.isArray(data.favorites)) {
                  this.favoriteLineups = this.validateAndCleanFavorites(data.favorites);
                  this.sortFavoritesByTime(); // åŠ è½½åæ’åº
                  //console.log('ä» localStorage åŠ è½½æ”¶è—æ•°æ®:', this.favoriteLineups.length, 'ä¸ªé˜µå®¹');

                  // å¦‚æœæœ‰æ”¶è—æ•°æ®ï¼Œæ˜¾ç¤ºåŠ è½½æˆåŠŸä¿¡æ¯
                  if (this.favoriteLineups.length > 0) {
                    //console.log(`âœ… æˆåŠŸåŠ è½½ ${this.favoriteLineups.length} ä¸ªæ”¶è—é˜µå®¹`);
                  }
                } else if (Array.isArray(data)) {
                  // å…¼å®¹æ—§æ ¼å¼ï¼ˆç›´æ¥æ˜¯æ•°ç»„ï¼‰
                  this.favoriteLineups = this.validateAndCleanFavorites(data);
                  this.sortFavoritesByTime(); // åŠ è½½åæ’åº
                  //console.log('ä» localStorage åŠ è½½æ”¶è—æ•°æ®ï¼ˆæ—§æ ¼å¼ï¼‰:', this.favoriteLineups.length, 'ä¸ªé˜µå®¹');
                } else {
                  console.warn('localStorage ä¸­çš„æ”¶è—æ•°æ®æ ¼å¼ä¸æ­£ç¡®');
                  this.favoriteLineups = [];
                }
              } else {
                //console.log('localStorage ä¸­æ²¡æœ‰æ”¶è—æ•°æ®');
                this.favoriteLineups = [];
              }
            } catch (error) {
              //console.log('åŠ è½½æ”¶è—æ•°æ®å¤±è´¥:', error.message);
              this.favoriteLineups = [];
            }
          },

          // éªŒè¯å’Œæ¸…ç†æ”¶è—æ•°æ®
          validateAndCleanFavorites(favorites) {
            if (!this.Data.current.TFTChampionData) {
              return favorites; // å¦‚æœè‹±é›„æ•°æ®è¿˜æ²¡åŠ è½½ï¼Œæš‚æ—¶ä¿ç•™æ‰€æœ‰æ”¶è—
            }

            const validFavorites = [];
            const currentHeroIds = this.Data.current.TFTChampionData.map(hero => hero.chessId);

            favorites.forEach(favorite => {
              // ç¡®ä¿æ”¶è—é¡¹æœ‰IDå­—æ®µ
              if (!favorite.id) {
                console.warn(`æ”¶è—é˜µå®¹"${favorite.name}"ç¼ºå°‘IDå­—æ®µï¼Œå°†è¢«è·³è¿‡`);
                return;
              }

              // é‡ç½®æ ‡è®°
              favorite.hasInvalidHeroes = false;

              // æ£€æŸ¥é˜µå®¹ä¸­çš„è‹±é›„æ˜¯å¦ä»ç„¶å­˜åœ¨
              if (favorite.hero_location_l9) {
                // å…ˆè§£å‹ç¼©æ•°æ®ä»¥è·å–æ­£ç¡®çš„è‹±é›„ä¿¡æ¯
                const decompressedFavorite = this.decompressLineupData(favorite);

                const invalidHeroes = decompressedFavorite.hero_location_l9.filter(hero => {
                  // æ£€æŸ¥è§£å‹ç¼©åçš„è‹±é›„æ•°æ®æ˜¯å¦å­˜åœ¨
                  return !hero.chessData;
                });

                if (invalidHeroes.length > 0) {
                  console.warn(`æ”¶è—é˜µå®¹"${favorite.name}" (ID: ${favorite.id})åŒ…å«å·²åˆ é™¤çš„è‹±é›„:`, invalidHeroes.map(h => {
                    // ä»åŸå§‹å‹ç¼©æ•°æ®ä¸­è·å–chessIdç”¨äºè°ƒè¯•
                    const originalHero = favorite.hero_location_l9.find(orig =>
                      orig.position === h.position
                    );
                    return originalHero ? originalHero.chessId : 'æœªçŸ¥è‹±é›„';
                  }));
                  // æ ‡è®°ä¸ºåŒ…å«æ— æ•ˆè‹±é›„ï¼Œä½†ä»ä¿ç•™
                  favorite.hasInvalidHeroes = true;
                }
              }

              // æ£€æŸ¥æ”¶è—æ—¶é—´ï¼Œå¦‚æœå¤ªæ—§å¯ä»¥æç¤ºç”¨æˆ·
              if (favorite.favoriteTime) {
                const favoriteDate = new Date(favorite.favoriteTime);
                const daysSinceFavorite = (Date.now() - favoriteDate.getTime()) / (1000 * 60 * 60 * 24);

                if (daysSinceFavorite > 30) { // è¶…è¿‡30å¤©çš„æ”¶è—
                  favorite.isOld = true;
                }
              }

              validFavorites.push(favorite);
            });

            // å¦‚æœæœ‰æ— æ•ˆæ•°æ®ï¼Œè‡ªåŠ¨ä¿å­˜æ¸…ç†åçš„ç»“æœ
            if (validFavorites.length !== favorites.length) {
              //console.log(`æ¸…ç†äº† ${favorites.length - validFavorites.length} ä¸ªæ— æ•ˆçš„æ”¶è—é¡¹`);
              this.saveFavoritesToFile();
            }

            return validFavorites;
          },

          // æ¸…ç†è¿‡æ—¶çš„æ”¶è—
          cleanOutdatedFavorites() {
            const originalCount = this.favoriteLineups.length;
            this.favoriteLineups = this.favoriteLineups.filter(favorite =>
              !favorite.hasInvalidHeroes && !favorite.isOld
            );

            const removedCount = originalCount - this.favoriteLineups.length;
            if (removedCount > 0) {
              this.saveFavoritesToFile();
              //console.log(`å·²æ¸…ç† ${removedCount} ä¸ªè¿‡æ—¶çš„æ”¶è—é˜µå®¹`);
              this.showInfoDialog('æ¸…ç†å®Œæˆ', `å·²æ¸…ç† ${removedCount} ä¸ªè¿‡æ—¶çš„æ”¶è—é˜µå®¹`);
            } else {
              this.showInfoDialog('æ¸…ç†å®Œæˆ', 'æ²¡æœ‰å‘ç°è¿‡æ—¶çš„æ”¶è—é˜µå®¹');
            }
          },
          // å¯¼å‡ºæ”¶è—æ•°æ®ï¼ˆæ‰‹åŠ¨ä¸‹è½½ï¼‰
          exportFavorites() {
            if (this.favoriteLineups.length === 0) {
              this.showWarningDialog('å¯¼å‡ºå¤±è´¥', 'æ²¡æœ‰æ”¶è—æ•°æ®å¯ä»¥å¯¼å‡º');
              return;
            }

            // ä»localStorageè·å–å®Œæ•´çš„æ•°æ®ç»“æ„
            try {
              const saved = localStorage.getItem('tft_favorite_lineups');
              let favoritesData;

              if (saved) {
                const data = JSON.parse(saved);
                if (data.favorites) {
                  // å·²ç»æ˜¯æ–°æ ¼å¼
                  favoritesData = data;
                } else {
                  // æ—§æ ¼å¼ï¼Œè½¬æ¢ä¸ºæ–°æ ¼å¼
                  favoritesData = {
                    version: "1.0",
                    lastUpdated: new Date().toISOString(),
                    count: this.favoriteLineups.length,
                    favorites: this.favoriteLineups
                  };
                }
              } else {
                // å¦‚æœlocalStorageä¸­æ²¡æœ‰æ•°æ®ï¼Œä½¿ç”¨å½“å‰å†…å­˜ä¸­çš„æ•°æ®
                favoritesData = {
                  version: "1.0",
                  lastUpdated: new Date().toISOString(),
                  count: this.favoriteLineups.length,
                  favorites: this.favoriteLineups
                };
              }

              const jsonString = JSON.stringify(favoritesData, null, 2);
              const blob = new Blob([jsonString], { type: 'application/json' });
              const url = URL.createObjectURL(blob);

              const link = document.createElement('a');
              link.href = url;
              link.download = 'favorites.json';
              link.style.display = 'none';

              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              URL.revokeObjectURL(url);

              this.showSuccessDialog('å¯¼å‡ºæˆåŠŸ', `å·²å¯¼å‡º ${this.favoriteLineups.length} ä¸ªæ”¶è—é˜µå®¹åˆ° favorites.json`);
            } catch (error) {
              console.error('å¯¼å‡ºå¤±è´¥:', error);
              this.showErrorDialog('å¯¼å‡ºå¤±è´¥', 'å¯¼å‡ºè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼Œè¯·é‡è¯•');
            }
          },

          // å¯¼å…¥æ”¶è—æ•°æ®
          importFavorites() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.style.display = 'none';

            input.onchange = (event) => {
              const file = event.target.files[0];
              if (!file) return;

              const reader = new FileReader();
              reader.onload = (e) => {
                try {
                  const data = JSON.parse(e.target.result);

                  if (data.favorites && Array.isArray(data.favorites)) {
                    const importedCount = data.favorites.length;
                    this.favoriteLineups = this.validateAndCleanFavorites(data.favorites);

                    // å¯¼å…¥åæ’åº
                    this.sortFavoritesByTime();

                    // ä¿å­˜åˆ°localStorage
                    this.saveFavoritesToFile();

                    this.showSuccessDialog('å¯¼å…¥æˆåŠŸ', `æˆåŠŸå¯¼å…¥ ${importedCount} ä¸ªæ”¶è—é˜µå®¹`);
                    //console.log('å¯¼å…¥æ”¶è—æ•°æ®æˆåŠŸ:', this.favoriteLineups.length, 'ä¸ªé˜µå®¹');
                  } else {
                    this.showErrorDialog('å¯¼å…¥å¤±è´¥', 'æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·é€‰æ‹©æœ‰æ•ˆçš„æ”¶è—æ–‡ä»¶');
                  }
                } catch (error) {
                  this.showErrorDialog('å¯¼å…¥å¤±è´¥', 'æ–‡ä»¶è§£æå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼');
                  console.error('å¯¼å…¥å¤±è´¥:', error);
                }
              };

              reader.readAsText(file);
              document.body.removeChild(input);
            };

            document.body.appendChild(input);
            input.click();
          },

          // æŒ‰æ”¶è—æ—¶é—´æ’åºï¼ˆæœ€æ–°çš„åœ¨å‰é¢ï¼‰
          sortFavoritesByTime() {
            this.favoriteLineups.sort((a, b) => {
              const timeA = new Date(a.favoriteTime || '1970-01-01').getTime();
              const timeB = new Date(b.favoriteTime || '1970-01-01').getTime();
              return timeB - timeA; // é™åºæ’åˆ—ï¼Œæœ€æ–°çš„åœ¨å‰é¢
            });
          },

          // è·å–å½“å‰æ”¶è—æ•°æ®çš„å­˜å‚¨å¤§å°
          getFavoriteStorageSize() {
            const data = {
              version: "1.0",
              lastUpdated: new Date().toISOString(),
              count: this.favoriteLineups.length,
              favorites: this.favoriteLineups
            };
            return new Blob([JSON.stringify(data)]).size;
          },

          // è·å–å­˜å‚¨ä½¿ç”¨æƒ…å†µ
          getStorageInfo() {
            const currentSize = this.getFavoriteStorageSize();
            const maxSize = 4 * 1024 * 1024; // 4MB
            const usagePercent = ((currentSize / maxSize) * 100).toFixed(1);
            const sizeMB = (currentSize / (1024 * 1024)).toFixed(2);

            return {
              currentSize,
              maxSize,
              usagePercent,
              sizeMB,
              count: this.favoriteLineups.length
            };
          },

          // è·å–å‹ç¼©æ•ˆæœç»Ÿè®¡
          getCompressionStats() {
            if (this.favoriteLineups.length === 0) return null;

            // è®¡ç®—å‹ç¼©å‰çš„å¤§å°ï¼ˆæ¨¡æ‹Ÿæœªå‹ç¼©çš„æ•°æ®ï¼‰
            const uncompressedData = this.favoriteLineups.map(lineup => this.decompressLineupData(lineup));
            const uncompressedSize = new Blob([JSON.stringify({
              version: "1.0",
              lastUpdated: new Date().toISOString(),
              count: uncompressedData.length,
              favorites: uncompressedData
            })]).size;

            // å½“å‰å‹ç¼©åçš„å¤§å°
            const compressedSize = this.getFavoriteStorageSize();

            // è®¡ç®—å‹ç¼©æ¯”ä¾‹
            const compressionRatio = ((uncompressedSize - compressedSize) / uncompressedSize * 100).toFixed(1);
            const spaceSaved = ((uncompressedSize - compressedSize) / (1024 * 1024)).toFixed(2);

            return {
              uncompressedSizeMB: (uncompressedSize / (1024 * 1024)).toFixed(2),
              compressedSizeMB: (compressedSize / (1024 * 1024)).toFixed(2),
              compressionRatio,
              spaceSavedMB: spaceSaved
            };
          },


          // Windowsé£æ ¼å¯¹è¯æ¡†æ–¹æ³•
          showInfoDialog(title, message) {
            this.dialogTitle = title;
            this.dialogType = 'info';
            this.dialogMessage = message;
            this.dialogButtons = [
              { text: 'ç¡®å®š', action: 'ok', primary: true }
            ];
            this.dialogCallback = null;
            this.showDialog = true;
          },

          showWarningDialog(title, message) {
            this.dialogTitle = title;
            this.dialogType = 'warning';
            this.dialogMessage = message;
            this.dialogButtons = [
              { text: 'ç¡®å®š', action: 'ok', primary: true }
            ];
            this.dialogCallback = null;
            this.showDialog = true;
          },

          showErrorDialog(title, message) {
            this.dialogTitle = title;
            this.dialogType = 'error';
            this.dialogMessage = message;
            this.dialogButtons = [
              { text: 'ç¡®å®š', action: 'ok', primary: true }
            ];
            this.dialogCallback = null;
            this.showDialog = true;
          },

          showSuccessDialog(title, message) {
            this.dialogTitle = title;
            this.dialogType = 'success';
            this.dialogMessage = message;
            this.dialogButtons = [
              { text: 'ç¡®å®š', action: 'ok', primary: true }
            ];
            this.dialogCallback = null;
            this.showDialog = true;
          },

          showConfirmDialog(title, message, callback) {
            this.dialogTitle = title;
            this.dialogType = 'confirm';
            this.dialogMessage = message;
            this.dialogButtons = [
              { text: 'å–æ¶ˆ', action: 'cancel', primary: false },
              { text: 'ç¡®å®š', action: 'confirm', primary: true }
            ];
            this.dialogCallback = callback;
            this.showDialog = true;
          },

          handleDialogButton(action) {
            if (action === 'confirm' && this.dialogCallback) {
              this.dialogCallback();
            }
            this.closeDialog();
          },

          closeDialog() {
            this.showDialog = false;
            this.dialogCallback = null;
          },

          // åŠŸèƒ½èœå•ç›¸å…³æ–¹æ³•
          reloadData() {
            this.showConfirmDialog(
              'é‡æ–°åŠ è½½æ•°æ®',
              'ç¡®å®šè¦é‡æ–°åŠ è½½æ¸¸æˆæ•°æ®å—ï¼Ÿè¿™å°†æ¸…é™¤å½“å‰é€‰ä¸­çš„è‹±é›„ã€‚',
              () => {
                this.selectedHeroes = [];
                this.selectedLineup = null;
                this.showLineupDetail = false;
                this.fetchDatachushi();
              }
            );
          },

          clearCache() {
            this.showConfirmDialog(
              'æ¸…é™¤ç¼“å­˜',
              'ç¡®å®šè¦æ¸…é™¤æœ¬åœ°ç¼“å­˜æ•°æ®å—ï¼Ÿè¿™å°†åˆ é™¤æ‰€æœ‰ä¸´æ—¶æ•°æ®ä½†ä¿ç•™æ”¶è—ã€‚',
              () => {
                try {
                  // ä¿å­˜æ”¶è—æ•°æ®
                  const favorites = localStorage.getItem('tft_favorite_lineups');
                  const settings = localStorage.getItem('tft_settings');

                  // æ¸…é™¤æ‰€æœ‰localStorageæ•°æ®
                  localStorage.clear();

                  // æ¢å¤æ”¶è—å’Œè®¾ç½®
                  if (favorites) {
                    localStorage.setItem('tft_favorite_lineups', favorites);
                  }
                  if (settings) {
                    localStorage.setItem('tft_settings', settings);
                  }

                  this.showSuccessDialog('æ¸…é™¤æˆåŠŸ', 'æœ¬åœ°ç¼“å­˜å·²æ¸…é™¤ï¼Œæ”¶è—æ•°æ®å·²ä¿ç•™');
                } catch (error) {
                  this.showErrorDialog('æ¸…é™¤å¤±è´¥', 'æ¸…é™¤ç¼“å­˜æ—¶å‘ç”Ÿé”™è¯¯ï¼š' + error.message);
                }
              }
            );
          },

          showSeasonInfo() {
            const currentSeason = this.getCurrentSeason();
            const seasonName = this.selectedSeason === 'current' ? 'å½“å‰èµ›å­£' : 'è½®æ¢èµ›å­£';
            const heroCount = this.Data.current.TFTChampionData ? this.Data.current.TFTChampionData.length : 0;
            const lineupCount = ((this.Data.current.OPGLineupList && this.Data.current.OPGLineupList.length) || 0) + ((this.Data.current.TFTLineupList && this.Data.current.TFTLineupList.length) || 0);

            this.showInfoDialog(
              'èµ›å­£ä¿¡æ¯',
              `<strong>å½“å‰ä½¿ç”¨ï¼š</strong>${seasonName}<br>
           <strong>èµ›å­£æ ‡è¯†ï¼š</strong>${currentSeason || 'æœªçŸ¥'}<br>
           <strong>è‹±é›„æ•°é‡ï¼š</strong>${heroCount} ä¸ª<br>
           <strong>é˜µå®¹æ•°é‡ï¼š</strong>${lineupCount} ä¸ª<br>
           <strong>æ”¶è—æ•°é‡ï¼š</strong>${this.favoriteLineups.length} ä¸ª`
            );
          },

          showHelp() {
            this.showInfoDialog(
              'ä½¿ç”¨è¯´æ˜',
              `<strong>åŸºæœ¬æ“ä½œï¼š</strong><br>
           â€¢ ç‚¹å‡»è‹±é›„å¤´åƒé€‰æ‹©/å–æ¶ˆé€‰æ‹©è‹±é›„<br>
           â€¢ æ‚¬åœè‹±é›„å¤´åƒæŸ¥çœ‹è¯¦ç»†ä¿¡æ¯<br>
           â€¢ ç‚¹å‡»é˜µå®¹æŸ¥çœ‹è¯¦ç»†é…ç½®<br><br>
           <strong>é˜µå®¹ç®¡ç†ï¼š</strong><br>
           â€¢ OP.GGï¼šç¬¬ä¸‰æ–¹ç»Ÿè®¡é˜µå®¹<br>
           â€¢ å®˜æ–¹ï¼šå®˜æ–¹æ¨èé˜µå®¹<br>
           â€¢ æ”¶è—ï¼šæ‚¨æ”¶è—çš„é˜µå®¹<br><br>
           <strong>ç­›é€‰åŠŸèƒ½ï¼š</strong><br>
           â€¢ æ”¯æŒè‹±é›„åç§°ã€æ‹¼éŸ³ã€èŒä¸šã€ç¾ç»Šæœç´¢<br>
           â€¢ å¯æŒ‰èŒä¸šã€ç¾ç»Šã€ç­‰çº§ç­›é€‰é˜µå®¹<br><br>
           <strong>æ”¶è—åŠŸèƒ½ï¼š</strong><br>
           â€¢ ç‚¹å‡»å¿ƒå½¢å›¾æ ‡æ”¶è—/å–æ¶ˆæ”¶è—é˜µå®¹<br>
           â€¢ æ”¯æŒå¯¼å…¥/å¯¼å‡ºæ”¶è—æ•°æ®`
            );
          },

          showShortcuts() {
            this.showInfoDialog(
              'å¿«æ·é”®è¯´æ˜',
              `<strong>é¼ æ ‡æ“ä½œï¼š</strong><br>
           â€¢ å·¦é”®ç‚¹å‡»ï¼šé€‰æ‹©è‹±é›„/é˜µå®¹<br>
           â€¢ æ‚¬åœï¼šæ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯<br>
           â€¢ å³é”®ï¼šï¼ˆæš‚æœªå®ç°ï¼‰<br><br>
           <strong>é”®ç›˜å¿«æ·é”®ï¼š</strong><br>
           â€¢ Escï¼šå…³é—­å½“å‰é¢æ¿<br>
           â€¢ Ctrl+Fï¼šèšç„¦æœç´¢æ¡†<br>
           â€¢ Ctrl+Rï¼šé‡æ–°åŠ è½½æ•°æ®<br>
           â€¢ Ctrl+Eï¼šå¯¼å‡ºæ”¶è—<br>
           â€¢ Ctrl+Iï¼šå¯¼å…¥æ”¶è—<br><br>
           <strong>æç¤ºï¼š</strong><br>
           â€¢ å¤§éƒ¨åˆ†æ“ä½œéƒ½æœ‰é¼ æ ‡æ‚¬åœæç¤º<br>
           â€¢ é•¿æŒ‰æŒ‰é’®å¯æŸ¥çœ‹è¯¦ç»†è¯´æ˜`
            );
          },

          showAbout() {
            const version = "1.0.0";
            const buildDate = new Date().toLocaleDateString();

            this.showInfoDialog(
              'å…³äºåº”ç”¨',
              `<strong>äº‘é¡¶ä¹‹å¼ˆè‹±é›„ç”»å»Š</strong><br>
           ç‰ˆæœ¬ï¼š${version}<br>
           æ„å»ºæ—¥æœŸï¼š${buildDate}<br><br>
           <strong>åŠŸèƒ½ç‰¹æ€§ï¼š</strong><br>
           â€¢ è‹±é›„ä¿¡æ¯æŸ¥çœ‹<br>
           â€¢ é˜µå®¹æ¨èä¸æ”¶è—<br>
           â€¢ æ™ºèƒ½æœç´¢ä¸ç­›é€‰<br>
           â€¢ æ•°æ®å¯¼å…¥å¯¼å‡º<br><br>
           <strong>æ•°æ®æ¥æºï¼š</strong><br>
           â€¢ å®˜æ–¹æ¸¸æˆæ•°æ®<br>
           â€¢ OP.GGç»Ÿè®¡æ•°æ®<br><br>
           <strong>æŠ€æœ¯æ ˆï¼š</strong><br>
           â€¢ Vue.js 3<br>
           â€¢ åŸç”ŸCSS<br>
           â€¢ LocalStorage`
            );
          },

          // æ˜¾ç¤ºå³å°†æ¨å‡ºåŠŸèƒ½çš„æç¤º
          showComingSoon(featureName) {
            this.showInfoDialog(
              'åŠŸèƒ½å¼€å‘ä¸­',
              `<strong>${featureName}</strong><br><br>
           è¯¥åŠŸèƒ½æ­£åœ¨å¼€å‘ä¸­ï¼Œæ•¬è¯·æœŸå¾…ï¼<br><br>
           <strong>é¢„è®¡åŠŸèƒ½ï¼š</strong><br>
           ${featureName === 'é˜µå®¹åˆ†æå™¨' ?
                'â€¢ é˜µå®¹å¼ºåº¦è¯„ä¼°<br>â€¢ ç¾ç»Šæ­é…åˆ†æ<br>â€¢ å¯¹æˆ˜èƒœç‡é¢„æµ‹<br>â€¢ è£…å¤‡ä¼˜å…ˆçº§æ¨è' :
                featureName === 'è£…å¤‡æ¨èå™¨' ?
                  'â€¢ æ™ºèƒ½è£…å¤‡æ­é…<br>â€¢ è£…å¤‡ä¼˜å…ˆçº§æ’åº<br>â€¢ åˆæˆè·¯å¾„è§„åˆ’<br>â€¢ è£…å¤‡æ•ˆæœåˆ†æ' :
                  'â€¢ æ›´å¤šå®ç”¨åŠŸèƒ½<br>â€¢ æå‡æ¸¸æˆä½“éªŒ<br>â€¢ æ•°æ®åˆ†æå·¥å…·<br>â€¢ ç­–ç•¥å»ºè®®'}<br><br>
           <strong>å¼€å‘è¿›åº¦ï¼š</strong> è§„åˆ’ä¸­<br>
           <strong>é¢„è®¡ä¸Šçº¿ï¼š</strong> å¾…å®š`
            );
          },

          saveSettings() {
            try {
              const settings = {
                showHeroNames: this.showHeroNames,
                showEquipTooltips: this.showEquipTooltips,
                autoSaveFavorites: this.autoSaveFavorites,
                lastUpdated: new Date().toISOString()
              };

              localStorage.setItem('tft_settings', JSON.stringify(settings));
              //console.log('è®¾ç½®å·²ä¿å­˜');
            } catch (error) {
              console.error('ä¿å­˜è®¾ç½®å¤±è´¥:', error);
            }
          },

          loadSettings() {
            try {
              const saved = localStorage.getItem('tft_settings');
              if (saved) {
                const settings = JSON.parse(saved);
                this.showHeroNames = settings.showHeroNames !== undefined ? settings.showHeroNames : true;
                this.showEquipTooltips = settings.showEquipTooltips !== undefined ? settings.showEquipTooltips : true;
                this.autoSaveFavorites = settings.autoSaveFavorites !== undefined ? settings.autoSaveFavorites : true;
                //console.log('è®¾ç½®å·²åŠ è½½');
              }
            } catch (error) {
              console.error('åŠ è½½è®¾ç½®å¤±è´¥:', error);
            }
          },
          resetSettings() {
            this.showHeroNames = true;
            this.showEquipTooltips = true;
            this.autoSaveFavorites = true;
            this.saveSettings();
            this.showInfoDialog('è®¾ç½®é‡ç½®', 'æ‰€æœ‰è®¾ç½®å·²æ¢å¤ä¸ºé»˜è®¤å€¼');
          },
          exportSettings() {
            const settings = {
              showHeroNames: this.showHeroNames,
              showEquipTooltips: this.showEquipTooltips,
              autoSaveFavorites: this.autoSaveFavorites
            };
            const jsonString = JSON.stringify(settings, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.href = url;
            link.download = 'settings.json';
            link.style.display = 'none';

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            this.showSuccessDialog('è®¾ç½®å¯¼å‡º', 'è®¾ç½®å·²æˆåŠŸå¯¼å‡ºåˆ° settings.json');
          },

          // è·å–è£…å¤‡é¡ºåºæ•°æ®
          getEquipmentOrderData() {
            if (!this.selectedLineup || !this.selectedLineup.equipment_order) {
              return [];
            }

            const equipmentIds = this.selectedLineup.equipment_order.split(',');
            return equipmentIds.map(id => {
              const equipment = this.getEquipmentById(id.trim());
              return equipment || { id: id.trim(), name: 'æœªçŸ¥è£…å¤‡', imagePath: '' };
            });
          },

          // è·å–æ¨èæµ·å…‹æ–¯æ•°æ®
          getRecommendedHexData() {
            if (!this.selectedLineup || !this.selectedLineup.hexbuff) {
              return { primary: [], alternative: [] };
            }

            const hexbuff = this.selectedLineup.hexbuff;
            const primary = hexbuff.recomm ? hexbuff.recomm.split(',').map(id => {
              const hex = this.getHexById(id.trim());
              return hex || { id: id.trim(), name: 'æœªçŸ¥æµ·å…‹æ–¯', imagePath: '' };
            }) : [];

            const alternative = hexbuff.replace ? hexbuff.replace.split(',').map(id => {
              const hex = this.getHexById(id.trim());
              return hex || { id: id.trim(), name: 'æœªçŸ¥æµ·å…‹æ–¯', imagePath: '' };
            }) : [];

            return { primary, alternative };
          },

          // è·å–é˜µå®¹æ”»ç•¥æ•°æ®
          getLineupStrategyData() {
            if (!this.selectedLineup) {
              return {
                d_time: '',
                early_info: '',
                enemy_info: '',
                equipment_info: '',
                hex_info: '',
                location_info: ''
              };
            }

            return {
              d_time: this.selectedLineup.d_time || '',
              early_info: this.selectedLineup.early_info || '',
              enemy_info: this.selectedLineup.enemy_info || '',
              equipment_info: this.selectedLineup.equipment_info || '',
              hex_info: this.selectedLineup.hex_info || '',
              location_info: this.selectedLineup.location_info || ''
            };
          },

          // è·å–è£…å¤‡é¡ºåºåˆ—è¡¨ï¼ˆHTMLæ¨¡æ¿ä¸­ä½¿ç”¨ï¼‰
          getEquipmentOrder(equipmentOrderString) {
            if (!equipmentOrderString) {
              return [];
            }
            return equipmentOrderString.split(',').map(id => id.trim()).filter(id => id);
          },

          // è·å–æµ·å…‹æ–¯åˆ—è¡¨ï¼ˆHTMLæ¨¡æ¿ä¸­ä½¿ç”¨ï¼‰
          getHexList(hexString) {
            if (!hexString) {
              return [];
            }
            return hexString.split(',').map(id => id.trim()).filter(id => id);
          },

          // æ£€æŸ¥æ˜¯å¦æœ‰æ”»ç•¥ä¿¡æ¯ï¼ˆHTMLæ¨¡æ¿ä¸­ä½¿ç”¨ï¼‰
          hasStrategyInfo(lineup) {
            if (!lineup) {
              return false;
            }
            return !!(lineup.d_time || lineup.early_info || lineup.enemy_info ||
              lineup.equipment_info || lineup.hex_info || lineup.location_info);
          },

          // åˆ‡æ¢å¯æ›¿æ¢è‹±é›„å±•å¼€/æ”¶èµ·çŠ¶æ€
          toggleReplaceableHeroesExpanded() {
            this.replaceableHeroesExpanded = !this.replaceableHeroesExpanded;
          },

          // æ£€æŸ¥æ˜¯å¦æœ‰å¯æ›¿æ¢è‹±é›„æ•°æ®
          hasReplaceableHeroes() {
            return this.selectedLineup && this.selectedLineup.hero_replace && this.selectedLineup.hero_replace.length > 0;
          },

          // è·å–å¯æ›¿æ¢è‹±é›„åˆ†ç»„æ•°æ®
          getReplaceableHeroGroups() {
            // ä»selectedLineupçš„hero_replaceå­—æ®µè·å–æ•°æ®ï¼Œç±»ä¼¼äºèµ›å­£ä¹‹å¿ƒçš„å®ç°
            if (!this.selectedLineup || !this.selectedLineup.hero_replace || this.selectedLineup.hero_replace.length === 0) {
              return [];
            }

            return this.selectedLineup.hero_replace.map(group => {
              // è§£æåŸè‹±é›„ID
              const originalHeroIds = group.hero_id ? group.hero_id.split(',').map(id => id.trim()).filter(id => id) : [];

              // è§£ææ›¿æ¢è‹±é›„ID
              const replacementHeroIds = group.replace_heros ? group.replace_heros.split(',').map(id => id.trim()).filter(id => id) : [];

              return {
                original: originalHeroIds,
                replacement: replacementHeroIds
              };
            });
          },
        },

        // æŒ‚è½½æ—¶è‡ªåŠ¨è°ƒç”¨ fetchDatachushi æ–¹æ³•
        mounted() {
          console.log("è°ƒç”¨æˆåŠŸ");
          
          // è·å–æµè§ˆå™¨å†…æ ¸ç‰ˆæœ¬
          const userAgent = navigator.userAgent;
          const chromeMatch = userAgent.match(/Chrome\/(\d+)/);
          
          if (chromeMatch) {
            const chromeVersion = parseInt(chromeMatch[1]);
            console.log(`æ£€æµ‹åˆ°Chromeç‰ˆæœ¬: ${chromeVersion}`);
            
            if (chromeVersion === 137) {
              console.log("æ£€æµ‹åˆ°Chrome 137ç‰ˆæœ¬ï¼Œæ‰§è¡Œç‰¹å®šé€»è¾‘");
              // è¯»å–æœ¬åœ°debug_original_json.txtæ–‡ä»¶
              try {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', './debug_original_json.txt', false); // åŒæ­¥è¯·æ±‚
                xhr.send();
                
                if (xhr.status === 200) {
                  window.yuanchengdata = JSON.parse(xhr.responseText);
                  console.log("æˆåŠŸè¯»å–debug_original_json.txtæ–‡ä»¶");
                } else {
                  console.error("è¯»å–debug_original_json.txtæ–‡ä»¶å¤±è´¥: HTTPçŠ¶æ€ç ", xhr.status);
                  window.yuanchengdata = null;
                }
              } catch (error) {
                console.error("è¯»å–debug_original_json.txtæ–‡ä»¶å¤±è´¥:", error);
                window.yuanchengdata = null;
              }
            }else{

              window.mbQuery(0x001, "getdata", onNative);
            }
          }
          
          
         
          console.log("è°ƒç”¨æˆåŠŸ");
          this.fetchDatachushi();
          this.loadFavoritesFromFile(); // åŠ è½½æ”¶è—æ•°æ®
          this.loadSettings(); // åŠ è½½ç”¨æˆ·è®¾ç½®

          // æ·»åŠ å…¨å±€é¼ æ ‡ç§»åŠ¨ç›‘å¬ï¼Œç¡®ä¿å¯ä»¥æ•è·äº‹ä»¶
          document.addEventListener('mousemove', (e) => {
            // åœ¨æ§åˆ¶å°æ˜¾ç¤ºé¼ æ ‡ä½ç½®ï¼ŒéªŒè¯äº‹ä»¶ç³»ç»Ÿå·¥ä½œæ­£å¸¸
            // //console.log('é¼ æ ‡ä½ç½®:', e.clientX, e.clientY);
          });

          // æ·»åŠ åˆ°mountedæ–¹æ³•ä¸­
          document.addEventListener('click', (e) => {

          });

          // æ·»åŠ é”®ç›˜å¿«æ·é”®æ”¯æŒ
          document.addEventListener('keydown', (e) => {
            // Escé”®å…³é—­å½“å‰é¢æ¿
            if (e.key === 'Escape') {
              if (this.showFilterPanel) {
                this.showFilterPanel = false;
              } else if (this.showLineupDetail) {
                this.closeLineupDetail();
              } else if (this.topMenu) {
                this.topMenu = '';
              }
            }

            // Ctrl+å¿«æ·é”®
            if (e.ctrlKey) {
              switch (e.key) {
                case 'f':
                case 'F':
                  e.preventDefault();
                  // èšç„¦æœç´¢æ¡†
                  const searchInput = document.querySelector('.search-input');
                  if (searchInput) {
                    searchInput.focus();
                  }
                  break;
                case 'r':
                case 'R':
                  e.preventDefault();
                  this.reloadData();
                  break;
                case 'e':
                case 'E':
                  e.preventDefault();
                  this.exportFavorites();
                  break;
                case 'i':
                case 'I':
                  e.preventDefault();
                  this.importFavorites();
                  break;
              }
            }
          });

          // ä¸ºstage-hero-cellæ·»åŠ ç‰¹å®šè°ƒè¯•
          const cells = document.querySelectorAll('.stage-hero-cell');
          cells.forEach(cell => {
            cell.addEventListener('click', (e) => {
              //console.log('Direct cell click:', e.target);
            });
          });
        }
      };
      Vue.createApp(App).mount("#app");
    </script>



</body>

</html>